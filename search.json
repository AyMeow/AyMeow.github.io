[{"title":"CTF赛题笔记","path":"/2024/03/28/CTF赛题笔记/","content":"流量分析NKCTF2024-Webshell_pro下载获取附件，解压得到一个数据包文件： 使用Wireshark打开查看，使用协议类型排序会发现响应包有内容： 随机抽一段解码发现为Base32编码： 猜测每一个响应包均有类似内容，且由题目可联想到应该是由响应包返回所需内容；于是采用脚本批量提取响应包并解码组合： 1234567891011from FlowAnalyzer import FlowAnalyzer# 一个用于流量分析的第三方库，具体用法：https://github.com/Byxs20/FlowAnalyzerimport base64# 以http为过滤规则读取数据包jsonPath = FlowAnalyzer.get_json_data(&quot;/tmp/webshell_pro.pcapng&quot;, display_filter = &quot;http&quot;)# 从HTTP请求和响应信息的字典对中遍历请求与相应，若有响应，则使用Base32解码并打印for request, response in FlowAnalyzer(jsonPath).generate_http_dict_pairs(): if response: print(base64.b32decode(response.file_data).decode()) 运行得出以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121┌──(kali㉿kali)-[~/桌面]└─$ python3 ctf.py root/bin/sh: 1: ipconfig: not foundeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 172.22.161.159 netmask 255.255.240.0 broadcast 172.22.175.255 inet6 fe80::215:5dff:fe18:b845 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:15:5d:18:b8:45 txqueuelen 1000 (Ethernet) RX packets 26778 bytes 10199358 (10.1 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1240 bytes 175322 (175.3 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0Dockerbinbootdevetchomeinitliblib32lib64libx32lost+foundmediamntmysql_dataoptprocrootrunsbinsnapsrvsystmpusrvarwslOHicoGwslbmJCJFwslgCJNfEwslhaGDbDCompressedDesktopDocumentsDownloadsFLAGMusicPicturesPublicTemplatesVideosWSLhint.py小明的日记.txtcat: 小明的日记.txt: No such file or directoryRkxBRyBpcyBOT1QgSEVSRSEhISEhISEhISEhCgoKUEFTU1dPUkQ6ClBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24KaW1wb3J0IGJhc2U2NA0KDQppbXBvcnQgbGlibnVtDQpmcm9tIENyeXB0by5QdWJsaWNLZXkgaW1wb3J0IFJTQQ0KDQpwdWJrZXkgPSAiIiItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLQ0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCZ1FDSy9xdjVQOGl4V2pvRkkycnpGNjJ0bTZzREZuUnNLc0doVlNDdXhRSXh1ZWhNV1FMbXY2VFB4eVRRUGVmSUt1ZnpmVUZhY2EvWUhrSVZJQzE5b2htRTVYNzM4VHR4R2JPZ2lHZWY0YnZkOXNVNk00Mms4dk1sQ1BKcDF3b0RGRE9Gb0JRcHI0WXpINFpUUjZQcytIUDhWRUlKTUc1dWlMUU9MeGRLZHhpNDFRSURBUUFCDQotLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0NCiIiIg0KDQpwcmlrZXkgPSAiIiItLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS0NCk1JSUNkZ0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQW1Bd2dnSmNBZ0VBQW9HQkFJcitxL2sveUxGYU9nVWphdk1YcmEyYnF3TVdkR3dxd2FGVklLN0ZBakc1NkV4WkF1YS9wTS9ISk5BOTU4Z3E1L045UVZweHI5Z2VRaFVnTFgyaUdZVGxmdmZ4TzNFWnM2Q0laNS9odTkzMnhUb3pqYVR5OHlVSThtblhDZ01VTTRXZ0ZDbXZoak1maGxOSG8rejRjL3hVUWdrd2JtNkl0QTR2RjBwM0dMalZBZ01CQUFFQ2dZQkRzcWF3VDVEQVVPSFJmdDZvWisvL2pzSk1Uck9GdTQxenRyS2tiUEFVcUNlc2grNFIxV1hBalk0d252WTFXRENCTjVDTkxMSW80UlB1bGkyUjgxSFo0T3BadWlIdjgxc05NY2NhdWhySnJpb0RkYnhoeGJNNy9qUTZNOVlhandkTmlzTDV6Q2xYQ09zMS95MDErOXZEaU1EazBrWDhoaUlZbHBQS0R3anFRUUpCQUw2WTBmdW9Kbmc1N0dHaGR3dk4yYzY1NnRMRFBqOUdSaTBzZmVlTXFhdlJUTXo2L3FlYTFMZEF1ekRoUm9TMldiOEFyaE9rWW5zMEdNYXp6YzFxNDI4Q1FRQzZzTTlPaVZSNEVWL2V3R25CbkYrMHAzYWxjWXIvL0dwMXdaNmZLSXJGSlFwYkhUemYyN0FoS2dPSjFxQjZBN1AvbVFTNkp2WURQc2dyVmtQTFJuWDdBa0VBci94cGZ5WGZCNG5zVXFXRlIzZjJVaVJteDk4UmZkbEVlUGVvOVlGek5Udlgzemt1bzlHWjhlOHFLTk1KaXdiWXpUMHlmdDU5TkdlQkxRL2V5bnFVcndKQUU2Tnh5ME1xL1k1bVZWcE1SYStiYWJlTUJZOVNIZWVCazIyUXNCRmx0Nk5UMlkzVHo0Q2VvSDU0N05FRkJKRExLSUlDTzBySjZrRjZjUVNjRVJBU2JRSkFaeTA4OHNWWTZESnRHUkxQdXlzdjNOaXlmRXZpa21jekNFa0RQZXg0c2h2RkxkZHdOVWxtaHptbDVwc2NJaWU0NG1CT0owdVgzN3krY28zcTZVb1JRZz09DQotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tDQoiIiINCg0KcHVia2V5ID0gUlNBLmltcG9ydF9rZXkocHVia2V5KQ0KcHJpa2V5ID0gUlNBLmltcG9ydF9rZXkocHJpa2V5KQ0KbiA9IHB1YmtleS5uDQoNCmRlZiBlbmNfcmVwbGFjZShiYXNlNjRfc3RyOiBzdHIpOg0KICAgIGJhc2U2NF9zdHIgPSBiYXNlNjRfc3RyLnJlcGxhY2UoIi8iLCAiZTVMZ15GTTVFUVllNSF5RiY2MiVWJFVHKkIqUmZRZU0iKQ0KICAgIGJhc2U2NF9zdHIgPSBiYXNlNjRfc3RyLnJlcGxhY2UoIisiLCAibjYmQjhHNm5FQDJ0dDRVUjZoM1FCdCo1JkMmcFZ1OFciKQ0KICAgIHJldHVybiBiYXNlNjRfc3RyLnJlcGxhY2UoIj0iLCAiSlhXVUR1TFVnd1JMS0Q5ZkQ2JlZZMmFGZUUmckBGZjIiKQ0KDQpkZWYgZW5jcnlwdChwbGFpbl90ZXh0KToNCiAgICAjIOengemSpeWKoOWvhg0KICAgIGNpcGhlcl90ZXh0ID0gYiIiDQogICAgZm9yIGkgaW4gcmFuZ2UoMCwgbGVuKHBsYWluX3RleHQpLCAxMjgpOg0KICAgICAgICBwYXJ0ID0gcGxhaW5fdGV4dFtpOmkrMTI4XQ0KICAgICAgICBlbmMgPSBsaWJudW0ubjJzKHBvdyhsaWJudW0uczJuKHBhcnQpLCBwcmlrZXkuZCwgbikpDQogICAgICAgIGNpcGhlcl90ZXh0ICs9IGVuYw0KICAgIHJldHVybiBlbmNfcmVwbGFjZShiYXNlNjQuYjY0ZW5jb2RlKGNpcGhlcl90ZXh0KS5kZWNvZGUoKSkNCg0KaWYgX19uYW1lX18gPT0gJ19fbWFpbl9fJzoNCiAgICBtID0gYiItUlNBLSIgKiAzMA0KICAgIHByaW50KGYi5Y6f5aeL5pWw5o2uOiB7bX0iKQ0KDQogICAgYyA9IGVuY3J5cHQobSkNCiAgICBwcmludChmIuWKoOWvhuaVsOaNrjoge2N9IikNCg==flag.txthint.py小明的日记.txtGood Luck! ByeBye~ 中间存在两段Base64编码，第一段解码得出以下内容，Flag不在这，但是附带了一个密码字段Password-based-encryption： 第二段解码出来是一个RSA的Python加密脚本： 加密脚本如下： 12345678910111213141516171819202122232425262728293031323334353637import base64import libnumfrom Crypto.PublicKey import RSApubkey = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;prikey = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg==-----END PRIVATE KEY-----&quot;&quot;&quot;pubkey = RSA.import_key(pubkey)prikey = RSA.import_key(prikey)n = pubkey.ndef enc_replace(base64_str: str): base64_str = base64_str.replace(&quot;/&quot;, &quot;e5Lg^FM5EQYe5!yF&amp;62%V$UG*B*RfQeM&quot;) base64_str = base64_str.replace(&quot;+&quot;, &quot;n6&amp;B8G6nE@2tt4UR6h3QBt*5&amp;C&amp;pVu8W&quot;) return base64_str.replace(&quot;=&quot;, &quot;JXWUDuLUgwRLKD9fD6&amp;VY2aFeE&amp;r@Ff2&quot;)def encrypt(plain_text): # 私钥加密 cipher_text = b&quot;&quot; for i in range(0, len(plain_text), 128): part = plain_text[i:i+128] enc = libnum.n2s(pow(libnum.s2n(part), prikey.d, n)) cipher_text += enc return enc_replace(base64.b64encode(cipher_text).decode())if __name__ == &#x27;__main__&#x27;: m = b&quot;-RSA-&quot; * 30 print(f&quot;原始数据: &#123;m&#125;&quot;) c = encrypt(m) print(f&quot;加密数据: &#123;c&#125;&quot;) 由以上加密脚本猜测应该要补全解密脚本，丢给GPT协助生成解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import base64from urllib import parseimport libnumfrom Crypto.PublicKey import RSAfrom FlowAnalyzer import FlowAnalyzerpubkey = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;prikey = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg==-----END PRIVATE KEY-----&quot;&quot;&quot;pubkey = RSA.import_key(pubkey)prikey = RSA.import_key(prikey)n = pubkey.njsonPath = FlowAnalyzer.get_json_data(&quot;/tmp/webshell_pro.pcapng&quot;, display_filter=&quot;http&quot;)def dec_replace(base64_str: str): base64_str = base64_str.replace(&quot;e5Lg^FM5EQYe5!yF&amp;62%V$UG*B*RfQeM&quot;, &quot;/&quot;) base64_str = base64_str.replace(&quot;n6&amp;B8G6nE@2tt4UR6h3QBt*5&amp;C&amp;pVu8W&quot;, &quot;+&quot;) return base64_str.replace(&quot;JXWUDuLUgwRLKD9fD6&amp;VY2aFeE&amp;r@Ff2&quot;, &quot;=&quot;).encode()def decrypt(cipher_text): # 公钥解密 cipher_text = base64.b64decode(dec_replace(cipher_text)) plain_text = b&quot;&quot; for i in range(0, len(cipher_text), 128): part = cipher_text[i:i+128] dec = libnum.n2s(pow(libnum.s2n(part), pubkey.e, n)) plain_text += dec return plain_text.decode()for request, response in FlowAnalyzer(jsonPath).generate_http_dict_pairs(): if request: file_data = parse.parse_qs(request.file_data)[b&#x27;shell&#x27;][0] print(decrypt(file_data.decode())) 运行得出以下内容： 123456789101112131415┌──(kali㉿kali)-[~/桌面]└─$ python3 decode.py whoamiipconfigifconfigls /ls /rootls /root/FLAGcd /root/FLAGcat 小明的日记.txtcd /root/FLAG &amp;&amp; base64 小明的日记.txtcd /root/FLAG &amp;&amp; base64 hint.pyecho U2FsdGVkX1+SslS2BbHfe3c4/t/KxLaM6ZFlOdbtfMHnG8lepnhMnde40tNOYjSvoErLzy0csL7c5d4TlMntBQ== &gt; /root/FLAG/flag.txtls /root/FLAGecho Good Luck! ByeBye~ 提取关键信息，Hacker将U2FsdGVkX1+SslS2BbHfe3c4/t/KxLaM6ZFlOdbtfMHnG8lepnhMnde40tNOYjSvoErLzy0csL7c5d4TlMntBQ==写进了&#x2F;root&#x2F;FLAG&#x2F;flag.txt文件中，这串编码看起来像Base64编码，但是尝试后不正确，结合前者的信息，应该是引入了密钥的非对称加密方法，尝试后发现为AES加密，而密钥为前面解出来的Password-based-encryption： 得到Flag：flag&#123;d0e1183c-07c3-49ea-b048-addbe6cc1b20&#125; [鹤城杯2021]流量分析下载打开附件，得到一个数据包： 使用Wireshark打开查看，简单使用协议类型排序，翻看一下可以发现这是Sql注入中布尔盲注的攻击流量： 在这回顾一下布尔盲注的知识： 布尔盲注爆出数据的原理其实是通过截取单个字符利用Ascii码来爆破字符，最后出现的Ascii码则是对应字符的Ascii码。 那根据这一性质，结合数据包中的内容，可以猜测Flag就是布尔盲注后的结果；故这有两种解法，一是根据数据包手动收集每一个字符对应的Ascii码，然后转换出来即是Flag，二则是通过脚本批量转换。 解法一：手动筛选后转换 1234a = [102,108,97,103,123,119,49,114,101,115,104,65,82,75,95,101,122,95,49,115,110,116,105,116,125,126,126]characters = [chr(i) for i in a]characters = &#x27;&#x27;.join(characters)print(characters) 即得Flag：flag&#123;w1reshARK_ez_1sntit&#125; 解法二：脚本批量筛选解析 1234567891011121314151617181920212223import re# 构建正则表达式，&#x27;\\d*&#x27;等同于&#x27;[0-9]*&#x27;。pattern = re.compile(r&quot;from%20t\\),(\\d*),1\\)\\)=(\\d*)&quot;)# 使用with来读取文件，with的好处是用完后可以自动关闭文件，减少开销。# &#x27;rb&#x27;表示用二进制只读模式读取。with open(&quot;/tmp/timu.pcapng&quot;, &quot;rb&quot;) as file: # 使用utf-8解码文件，&#x27;ignore&#x27;表示如果文件包含无法使用前者编码的字节时进行忽略，并将内容存储至data变量中。 data = file.read().decode(&quot;utf-8&quot;, &quot;ignore&quot;)# 通过正则匹配文件，形成元组。matches = pattern.findall(data)flag = [&#x27;&#x27;] * 31# 对于每个元组 t，使用 lambda 函数将其第一个元素（索引）转换为整数，并将其第二个元素（ASCII 码）转换为对应的字符。然后，通过 map() 函数对 matches 中的每个元组执行这个转换，得到一个由索引和对应字符组成的元组的迭代器。接着，使用 for 循环遍历这个迭代器中的每个元组。在循环中，index 变量存储索引值，value 变量存储对应的字符。for index, value in map(lambda t: (int(t[0]), chr(int(t[1]))), matches): flag[index] = value# 将flag拼接起来。print(&#x27;&#x27;.join(flag)) 即得Flag：flag&#123;w1reshARK_ez_1sntit&#125; 压缩包攻击BugKu-请攻击这个压缩包下载获取附件，是一个加密了的压缩包，除此之外没有任何提示： 解题思路： 暴力破解 伪加密 明文攻击 若是突破点为暴力破解，应有少量的提示，大概率不可能纯暴力破解，时间太长效率不高；可以利用010editor查看是否为伪加密： 如何判断真加密伪加密？ ​\tfrFlags 和 deFlags ​\t压缩源文件数据区中的全局方式位标记是判断压缩包有无伪加密的重要标志，即压缩源文件数据区的第7、第8两个字节09 00。 ​\tZIP的压缩源文件数据区全局方式位标记在010 Editor显示的文件结构中即为ushort frFlags。 ​\t压缩文件目录区的全局方式位标记是进行伪加密的关键，即压缩文件目录区的第9、第10两个字节。 ​\tZIP的压缩文件目录区全局方式位标记在010 Editor显示的文件结构中即为ushort deFlags。 ​\t无加密的ZIP： 压缩源文件数据区的全局方式位标记应当为00 00，且压缩源文件目录区的全局方式位标记应当为00 00 真加密的ZIP: 压缩源文件数据区的全局方式位标记应当为09 00，且压缩源文件目录区的全局方式位标记应当为09 00 伪加密的ZIP: 压缩源文件数据区的全局方式位标记应当为00 00，且压缩文件目录区的全局方式位标记应当为09 00。 可以确认是真加密，那接下来往明文攻击那方向思考，查询一下压缩包明文攻击的前置条件： 第一第二点，我们并不满足，但是第三种利用7z查看加密算法后，发现可以利用： 利用ZipCrypto Store的特性，只需要知道加密压缩包内容的12个字节就可以对该压缩包进行明文攻击破解，标准Png文件的文件头都是一致的，所以我们可以拟造一个只有文件头的Png文件；Png文件头：89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52 12echo 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_header# xxd -r -ps：将16进制数转换成ASCII文本 效果是这样的： 接下来使用bkcrack工具进行明文攻击，将加密的压缩包和刚刚拟造的png_header放在同一目录下： 1234567time bkcrack -C file.zip -c flag.png -p png_header -o 0 &gt; 1.log&amp;# time：加上time参数查看计算爆破时间# -C：选择加密压缩包# -c：选择压缩包的密文部分# -p：选择的明文文件# -o：指定的明文在压缩包内目标文件的偏移量# &gt; 1.log&amp;：后台运行，并将结果存入1.log 工具链接：https://github.com/kimci86/bkcrack 12# 使用以下命令查看进度 tail -f 1.log 可以获得三段密钥：92802c24 9955f8d6 65c652b8 利用这三段密钥即可把flag.png文件取出来： 1bkcrack -C file.zip -c flag.png -k 92802c24 9955f8d6 65c652b8 -d try.png 在同级目录下即可获得try.png： 打开图片即可获得Flag： 即得Flag：BugKu&#123;不是非得两个文件你才能明文攻击&#125; ReverseSWPUCTF 2021 新生赛-re1下载附件，是一个exe可执行文件： 二话不说直接拖进IDA中分析分析，拖进去后先查找main函数，然后F5反编译看看伪代码的逻辑： 主体代码逻辑如下： 12345678910111213141516171819strcpy(Str2, &quot;&#123;34sy_r3v3rs3&#125;&quot;); // 将目标字符串 &quot;&#123;34sy_r3v3rs3&#125;&quot; 复制到 Str2 数组中 printf(&quot;please put your flag:&quot;); // 打印提示消息，要求用户输入标志 scanf(&quot;%s&quot;, Str1); // 从用户输入中读取字符串，并存储到 Str1 数组中 for ( i = 0; i &lt;= 665; ++i ) // 循环遍历 Str1 中的每个字符，进行替换操作 &#123; if ( Str1[i] == 101 ) // 如果当前字符是 ASCII 值为 101 的 &#x27;e&#x27;，则将其替换为 ASCII 值为 51 的 &#x27;3&#x27; Str1[i] = 51; &#125; for ( i = 0; i &lt;= 665; ++i ) &#123; if ( Str1[i] == 97 ) // 如果当前字符是 ASCII 值为 97 的 &#x27;a&#x27;，则将其替换为 ASCII 值为 52 的 &#x27;4&#x27; Str1[i] = 52; &#125; if ( strcmp(Str1, Str2) ) // 比较 Str1 和 Str2 是否相等，若不相等则执行下一步操作 printf(&quot;you are wrong,see again!&quot;); else printf(&quot;you are right!&quot;); // 若相等则打印提示消息，表示输入正确 system(&quot;pause&quot;); return 0; 以上代码实现了一个替换字符的动作，用户输入的“Flag”经过上述转换后若是等于”{34sy_r3v3rs3}”则输入正确；也就是说只需要将得到”{34sy_r3v3rs3}”的动作逆转即可，逆转过程使用Python实现： 123456789101112str = &#x27;&#123;34sy_r3v3rs3&#125;&#x27;new_str = &#x27;&#x27; # 创建一个新的字符串来存储修改后的结果for i in str: if ord(i) == 51: new_str += chr(101) # 将字符 &#x27;3&#x27; 替换为字符 &#x27;e&#x27; elif ord(i) == 52: new_str += chr(97) # 将字符 &#x27;4&#x27; 替换为字符 &#x27;a&#x27; else: new_str += i # 如果不需要替换，则保留原字符print(new_str) 运行结果如下图： 对结果进行验证： 结果正确，题目摘抄于NSSCTF平台，即完整Flag为：NSSCTF&#123;easy_reverse&#125; HUBUCTF 2022 新生赛-simple_RE下载附件，是一个压缩包，里面有一个exe可执行文件： 拖进IDA进行分析，发现有一串字符串，先找到main函数： 按F5反编译分析伪代码的结构： 代码如下，丢去GPT协助分析一下，程序的大致逻辑是用户输入一个字符串，经过函数转换后与内置的另一个字符串进行比较，正确即显示success!： 12345678910111213141516171819int __fastcall main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+24h] [rbp-44h] BYREF void *Buf1; // [rsp+28h] [rbp-40h] BYREF char v6[56]; // [rsp+30h] [rbp-38h] BYREF sub_401770(argc, argv, envp); printf(&quot;please input the flag:&quot;); scanf(&quot;%s&quot;, v6); Buf1 = 0i64; sub_401570(v6, &amp;Buf1, &amp;v4); if ( !memcmp(Buf1, a5mc58bphliax7j, v4) ) printf(&quot; success!&quot;); else printf(&quot; failed!&quot;); if ( Buf1 ) free(Buf1); return 0;&#125; &#x2F;&#x2F; int v4; &#x2F;&#x2F; [rsp+24h] [rbp-44h] BYREF：定义一个整型变量 v4，用于存储结果长度。 &#x2F;&#x2F; void *Buf1; &#x2F;&#x2F; [rsp+28h] [rbp-40h] BYREF：定义一个指针变量 Buf1，用于存储 Base64 编码后的结果。 &#x2F;&#x2F; char v6[56]; &#x2F;&#x2F; [rsp+30h] [rbp-38h] BYREF：定义一个字符数组 v6，用于存储用户输入的字符串，长度为 56 个字节。 &#x2F;&#x2F; sub_401770(argc, argv, envp);：调用子函数 sub_401770，并将 argc、argv 和 envp 作为参数传递进去。该函数的具体功能需要查看其定义。 &#x2F;&#x2F; printf(“please input the flag:”);：打印提示信息，要求用户输入标志。 &#x2F;&#x2F; scanf(“%s”, v6);：通过键盘输入获取用户输入的字符串，并存储在变量 v6 中。 &#x2F;&#x2F; Buf1 &#x3D; 0i64;：将指针变量 Buf1 初始化为 NULL，即空指针。 &#x2F;&#x2F; sub_401570(v6, &amp;Buf1, &amp;v4);：调用子函数 sub_401570，并将用户输入的字符串 v6、结果指针的地址 &amp;Buf1 和结果长度的地址 &amp;v4 作为参数传递进去。该函数的具体功能需要查看其定义。 &#x2F;&#x2F; if ( !memcmp(Buf1, a5mc58bphliax7j, v4) )：通过 memcmp 函数比较 Buf1 指向的内存区域和 a5mc58bphliax7j 指向的内存区域的前 v4 个字节是否相等。如果相等，则说明用户输入的标志是正确的。 &#x2F;&#x2F; printf(“ success!”);：打印成功信息。 &#x2F;&#x2F; else printf(“ failed!”);：如果用户输入的标志不正确，则打印失败信息。 &#x2F;&#x2F; if ( Buf1 ) free(Buf1);：释放动态分配的内存空间，避免内存泄漏。 &#x2F;&#x2F; return 0;：程序正常退出，并返回 0 表示成功。 从代码中可以看到，用户输入的字符串被函数sub_401570转换后被用来与a5mc58bphliax7j变量进行比较，点进a5mc58bphliax7j中查看为一串Base64的编码： 再看看函数sub_401570实现的是什么功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465__int64 __fastcall sub_401570(const char *a1, _QWORD *a2, int *a3)&#123; int v6; // r15d int v7; // r12d int v8; // r13d __int64 v9; // r14 _BYTE *v10; // rax _BYTE *v11; // r9 __int64 v12; // r8 char v13; // cl char v14; // r11 char v15; // r10 __int64 result; // rax v6 = strlen(a1); v7 = v6 % 3; if ( v6 % 3 ) &#123; v8 = 4 * (v6 / 3) + 4; v9 = v8; v10 = malloc(v8 + 1i64); v10[v8] = 0; if ( v6 &lt;= 0 ) goto LABEL_5; &#125; else &#123; v8 = 4 * (v6 / 3); v9 = v8; v10 = malloc(v8 + 1i64); v10[v8] = 0; if ( v6 &lt;= 0 ) goto LABEL_8; &#125; v11 = v10; v12 = 0i64; do &#123; v11 += 4; v13 = a1[v12]; *(v11 - 4) = aQvejafhmuyjbac[v13 &gt;&gt; 2]; v14 = a1[v12 + 1]; *(v11 - 3) = aQvejafhmuyjbac[(v14 &gt;&gt; 4) | (16 * v13) &amp; 0x30]; v15 = a1[v12 + 2]; v12 += 3i64; *(v11 - 2) = aQvejafhmuyjbac[(v15 &gt;&gt; 6) | (4 * v14) &amp; 0x3C]; *(v11 - 1) = aQvejafhmuyjbac[v15 &amp; 0x3F]; &#125; while ( v6 &gt; (int)v12 );LABEL_5: if ( v7 == 1 ) &#123; v10[v9 - 2] = 61; v10[v9 - 1] = 61; &#125; else if ( v7 == 2 ) &#123; v10[v9 - 1] = 61; &#125;LABEL_8: *a2 = v10; result = 0i64; *a3 = v8; return result;&#125; 丢进GPT内分析后知道这段代码实现的是一个Base64编码的过程，但是字母表更换了，使用了aQvejafhmuyjbac内的字母表： 这里附上Base64编码的原理： 将二进制数据分割成 6 位一组： 首先，将需要编码的二进制数据按照 6 位一组进行分割。 将每组 6 位转换成一个 Base64 字符： 对于每一组 6 位的二进制数据，将其转换成对应的 Base64 字符。Base64 字符集包含 64 个字符，通常包括 A-Z、a-z、0-9 这 62 个字符，以及两个额外的字符，通常是 “+” 和 “&#x2F;“，共计 64 个字符。 对不足 6 位的二进制数据进行填充： 如果最后一组的二进制数据不足 6 位，需要进行填充。通常使用字符 “&#x3D;” 来填充。 将所有的 Base64 字符串连接起来： 将每组转换后的 Base64 字符串连接起来，形成最终的 Base64 编码结果。 至此，整个程序的逻辑为：接受用户输入的字符串，然后通过自定义的字母表进行Base64编码，然后再与给定字符串进行比较，一样则成功，反之失败；则解题关键就是将给定的字符串通过自定义的字母表Base64解码即可： 或者通过脚本转换： 123456789101112131415161718import base64str1 = &#x27;5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM/8==&#x27;string1 = &quot;qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print(base64.b64decode(str1.translate(str.maketrans(string1,string2))))# maketrans函数的作用是创建字符映射的转换表。# translate(table)函数的作用是根据参数 table 给出的表（包含 256 个字符）转换字符串的字符，table是通过 maketrans()方法转换而来。# 以上面的这个例子来说，即将字符串str1中的涉及string1的内容（部分也算）转换成string2中的内容，再通过默认的Base64方法解码。# 那么str1是如何计算出来的呢？为了更加方便理解以上代码，以下是str1的推导过程。import base64string1 = &quot;qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;flag = &#x27;NSSCTF&#123;a8d4347722800e72e34e1aba3fe914ae&#125;&#x27;print(base64.b64encode(flag.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;).translate(str.maketrans(string2, string1)))# 结合以上两段代码，能更好的理解“base64.b64decode(str1.translate(str.maketrans(string1,string2)))”此段代码的工作原理。 最后将结果输入进程序验证是否正确，程序一闪而过，可看到success！的字样： 题目摘自NSSCTF平台，即Flag为：NSSCTF&#123;a8d4347722800e72e34e1aba3fe914ae&#125; HNCTF 2022 Week1-X0r下载附件，便于记录进行改名，为一个exe执行程序： 丢尽PE查壳和其他信息： 无壳，64位，丢进64位IDA中分析，找到main函数，F5反编译分析伪代码： 代码如下： 123456789101112131415161718192021222324int __fastcall main(int argc, const char **argv, const char **envp)&#123; char Str[44]; // [rsp+20h] [rbp-30h] BYREF int i; // [rsp+4Ch] [rbp-4h] _main(); puts(&quot;please input your flag!&quot;); scanf(&quot;%s&quot;, Str); if ( strlen(Str) != 22 ) &#123; printf(&quot;strlen error!&quot;); exit(0); &#125; for ( i = 0; i &lt;= 21; ++i ) &#123; if ( arr[i] != (Str[i] ^ 0x34) + 900 ) &#123; printf(&quot;flag error!&quot;); exit(0); &#125; &#125; printf(&quot;you are right!&quot;); return 0;&#125; 代码主要有一个判断点，判断输入的字符串长度是否等于22；确认字符串长度无误后对输入的字符串进行遍历，让字符串里的每一个字符与0x34进行异或并+900，最后与arr数组里的字符比较，错误则输出错误信息。那解题的关键即在arr数组中，点进去看看内容： 结合前面的分析，思路已经很清晰了，只需要将arr数组中的数据逆向回去即可得到Flag，使用Python转换，脚本如下： 上图数据中的“h”代表十六进制的意思； “2 dup”则表示该数据重复两次的意思。 1234arr = [0x3FE,0x3EB,0x3EB,0x3FB,0x3E4,0x3F6,0x3D3,0x3D0,0x388,0x3CA,0x3EF,0x389,0x3CB,0x3EF,0x3CB,0x388,0x3EF,0x3D5,0x3D9,0x3CB,0x3D1,0x3CD]flag = &quot;&quot;for i in range(len(arr)): flag += chr((arr[i] - 900) ^ 0x34) 将arr中的数据先-900再与0x34异或即可获得Flag： 题目摘自NSSCTF平台，即Flag为：NSSCTF&#123;x0r_1s_s0_easy&#125;"}]