[{"title":"CTF赛题笔记","path":"/2024/03/28/CTF赛题笔记/","content":"流量分析NKCTF2024-Webshell_pro下载获取附件，解压得到一个数据包文件： 使用Wireshark打开查看，使用协议类型排序会发现响应包有内容： 随机抽一段解码发现为Base32编码： 猜测每一个响应包均有类似内容，且由题目可联想到应该是由响应包返回所需内容；于是采用脚本批量提取响应包并解码组合： 1234567891011from FlowAnalyzer import FlowAnalyzer# 一个用于流量分析的第三方库，具体用法：https://github.com/Byxs20/FlowAnalyzerimport base64# 以http为过滤规则读取数据包jsonPath = FlowAnalyzer.get_json_data(&quot;/tmp/webshell_pro.pcapng&quot;, display_filter = &quot;http&quot;)# 从HTTP请求和响应信息的字典对中遍历请求与相应，若有响应，则使用Base32解码并打印for request, response in FlowAnalyzer(jsonPath).generate_http_dict_pairs(): if response: print(base64.b32decode(response.file_data).decode()) 运行得出以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121┌──(kali㉿kali)-[~/桌面]└─$ python3 ctf.py root/bin/sh: 1: ipconfig: not foundeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 172.22.161.159 netmask 255.255.240.0 broadcast 172.22.175.255 inet6 fe80::215:5dff:fe18:b845 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:15:5d:18:b8:45 txqueuelen 1000 (Ethernet) RX packets 26778 bytes 10199358 (10.1 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1240 bytes 175322 (175.3 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0Dockerbinbootdevetchomeinitliblib32lib64libx32lost+foundmediamntmysql_dataoptprocrootrunsbinsnapsrvsystmpusrvarwslOHicoGwslbmJCJFwslgCJNfEwslhaGDbDCompressedDesktopDocumentsDownloadsFLAGMusicPicturesPublicTemplatesVideosWSLhint.py小明的日记.txtcat: 小明的日记.txt: No such file or directoryRkxBRyBpcyBOT1QgSEVSRSEhISEhISEhISEhCgoKUEFTU1dPUkQ6ClBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24KaW1wb3J0IGJhc2U2NA0KDQppbXBvcnQgbGlibnVtDQpmcm9tIENyeXB0by5QdWJsaWNLZXkgaW1wb3J0IFJTQQ0KDQpwdWJrZXkgPSAiIiItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLQ0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCZ1FDSy9xdjVQOGl4V2pvRkkycnpGNjJ0bTZzREZuUnNLc0doVlNDdXhRSXh1ZWhNV1FMbXY2VFB4eVRRUGVmSUt1ZnpmVUZhY2EvWUhrSVZJQzE5b2htRTVYNzM4VHR4R2JPZ2lHZWY0YnZkOXNVNk00Mms4dk1sQ1BKcDF3b0RGRE9Gb0JRcHI0WXpINFpUUjZQcytIUDhWRUlKTUc1dWlMUU9MeGRLZHhpNDFRSURBUUFCDQotLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0NCiIiIg0KDQpwcmlrZXkgPSAiIiItLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS0NCk1JSUNkZ0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQW1Bd2dnSmNBZ0VBQW9HQkFJcitxL2sveUxGYU9nVWphdk1YcmEyYnF3TVdkR3dxd2FGVklLN0ZBakc1NkV4WkF1YS9wTS9ISk5BOTU4Z3E1L045UVZweHI5Z2VRaFVnTFgyaUdZVGxmdmZ4TzNFWnM2Q0laNS9odTkzMnhUb3pqYVR5OHlVSThtblhDZ01VTTRXZ0ZDbXZoak1maGxOSG8rejRjL3hVUWdrd2JtNkl0QTR2RjBwM0dMalZBZ01CQUFFQ2dZQkRzcWF3VDVEQVVPSFJmdDZvWisvL2pzSk1Uck9GdTQxenRyS2tiUEFVcUNlc2grNFIxV1hBalk0d252WTFXRENCTjVDTkxMSW80UlB1bGkyUjgxSFo0T3BadWlIdjgxc05NY2NhdWhySnJpb0RkYnhoeGJNNy9qUTZNOVlhandkTmlzTDV6Q2xYQ09zMS95MDErOXZEaU1EazBrWDhoaUlZbHBQS0R3anFRUUpCQUw2WTBmdW9Kbmc1N0dHaGR3dk4yYzY1NnRMRFBqOUdSaTBzZmVlTXFhdlJUTXo2L3FlYTFMZEF1ekRoUm9TMldiOEFyaE9rWW5zMEdNYXp6YzFxNDI4Q1FRQzZzTTlPaVZSNEVWL2V3R25CbkYrMHAzYWxjWXIvL0dwMXdaNmZLSXJGSlFwYkhUemYyN0FoS2dPSjFxQjZBN1AvbVFTNkp2WURQc2dyVmtQTFJuWDdBa0VBci94cGZ5WGZCNG5zVXFXRlIzZjJVaVJteDk4UmZkbEVlUGVvOVlGek5Udlgzemt1bzlHWjhlOHFLTk1KaXdiWXpUMHlmdDU5TkdlQkxRL2V5bnFVcndKQUU2Tnh5ME1xL1k1bVZWcE1SYStiYWJlTUJZOVNIZWVCazIyUXNCRmx0Nk5UMlkzVHo0Q2VvSDU0N05FRkJKRExLSUlDTzBySjZrRjZjUVNjRVJBU2JRSkFaeTA4OHNWWTZESnRHUkxQdXlzdjNOaXlmRXZpa21jekNFa0RQZXg0c2h2RkxkZHdOVWxtaHptbDVwc2NJaWU0NG1CT0owdVgzN3krY28zcTZVb1JRZz09DQotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tDQoiIiINCg0KcHVia2V5ID0gUlNBLmltcG9ydF9rZXkocHVia2V5KQ0KcHJpa2V5ID0gUlNBLmltcG9ydF9rZXkocHJpa2V5KQ0KbiA9IHB1YmtleS5uDQoNCmRlZiBlbmNfcmVwbGFjZShiYXNlNjRfc3RyOiBzdHIpOg0KICAgIGJhc2U2NF9zdHIgPSBiYXNlNjRfc3RyLnJlcGxhY2UoIi8iLCAiZTVMZ15GTTVFUVllNSF5RiY2MiVWJFVHKkIqUmZRZU0iKQ0KICAgIGJhc2U2NF9zdHIgPSBiYXNlNjRfc3RyLnJlcGxhY2UoIisiLCAibjYmQjhHNm5FQDJ0dDRVUjZoM1FCdCo1JkMmcFZ1OFciKQ0KICAgIHJldHVybiBiYXNlNjRfc3RyLnJlcGxhY2UoIj0iLCAiSlhXVUR1TFVnd1JMS0Q5ZkQ2JlZZMmFGZUUmckBGZjIiKQ0KDQpkZWYgZW5jcnlwdChwbGFpbl90ZXh0KToNCiAgICAjIOengemSpeWKoOWvhg0KICAgIGNpcGhlcl90ZXh0ID0gYiIiDQogICAgZm9yIGkgaW4gcmFuZ2UoMCwgbGVuKHBsYWluX3RleHQpLCAxMjgpOg0KICAgICAgICBwYXJ0ID0gcGxhaW5fdGV4dFtpOmkrMTI4XQ0KICAgICAgICBlbmMgPSBsaWJudW0ubjJzKHBvdyhsaWJudW0uczJuKHBhcnQpLCBwcmlrZXkuZCwgbikpDQogICAgICAgIGNpcGhlcl90ZXh0ICs9IGVuYw0KICAgIHJldHVybiBlbmNfcmVwbGFjZShiYXNlNjQuYjY0ZW5jb2RlKGNpcGhlcl90ZXh0KS5kZWNvZGUoKSkNCg0KaWYgX19uYW1lX18gPT0gJ19fbWFpbl9fJzoNCiAgICBtID0gYiItUlNBLSIgKiAzMA0KICAgIHByaW50KGYi5Y6f5aeL5pWw5o2uOiB7bX0iKQ0KDQogICAgYyA9IGVuY3J5cHQobSkNCiAgICBwcmludChmIuWKoOWvhuaVsOaNrjoge2N9IikNCg==flag.txthint.py小明的日记.txtGood Luck! ByeBye~ 中间存在两段Base64编码，第一段解码得出以下内容，Flag不在这，但是附带了一个密码字段Password-based-encryption： 第二段解码出来是一个RSA的Python加密脚本： 加密脚本如下： 12345678910111213141516171819202122232425262728293031323334353637import base64import libnumfrom Crypto.PublicKey import RSApubkey = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;prikey = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg==-----END PRIVATE KEY-----&quot;&quot;&quot;pubkey = RSA.import_key(pubkey)prikey = RSA.import_key(prikey)n = pubkey.ndef enc_replace(base64_str: str): base64_str = base64_str.replace(&quot;/&quot;, &quot;e5Lg^FM5EQYe5!yF&amp;62%V$UG*B*RfQeM&quot;) base64_str = base64_str.replace(&quot;+&quot;, &quot;n6&amp;B8G6nE@2tt4UR6h3QBt*5&amp;C&amp;pVu8W&quot;) return base64_str.replace(&quot;=&quot;, &quot;JXWUDuLUgwRLKD9fD6&amp;VY2aFeE&amp;r@Ff2&quot;)def encrypt(plain_text): # 私钥加密 cipher_text = b&quot;&quot; for i in range(0, len(plain_text), 128): part = plain_text[i:i+128] enc = libnum.n2s(pow(libnum.s2n(part), prikey.d, n)) cipher_text += enc return enc_replace(base64.b64encode(cipher_text).decode())if __name__ == &#x27;__main__&#x27;: m = b&quot;-RSA-&quot; * 30 print(f&quot;原始数据: &#123;m&#125;&quot;) c = encrypt(m) print(f&quot;加密数据: &#123;c&#125;&quot;) 由以上加密脚本猜测应该要补全解密脚本，丢给GPT协助生成解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import base64from urllib import parseimport libnumfrom Crypto.PublicKey import RSAfrom FlowAnalyzer import FlowAnalyzerpubkey = &quot;&quot;&quot;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCK/qv5P8ixWjoFI2rzF62tm6sDFnRsKsGhVSCuxQIxuehMWQLmv6TPxyTQPefIKufzfUFaca/YHkIVIC19ohmE5X738TtxGbOgiGef4bvd9sU6M42k8vMlCPJp1woDFDOFoBQpr4YzH4ZTR6Ps+HP8VEIJMG5uiLQOLxdKdxi41QIDAQAB-----END PUBLIC KEY-----&quot;&quot;&quot;prikey = &quot;&quot;&quot;-----BEGIN PRIVATE KEY-----MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAIr+q/k/yLFaOgUjavMXra2bqwMWdGwqwaFVIK7FAjG56ExZAua/pM/HJNA958gq5/N9QVpxr9geQhUgLX2iGYTlfvfxO3EZs6CIZ5/hu932xTozjaTy8yUI8mnXCgMUM4WgFCmvhjMfhlNHo+z4c/xUQgkwbm6ItA4vF0p3GLjVAgMBAAECgYBDsqawT5DAUOHRft6oZ+//jsJMTrOFu41ztrKkbPAUqCesh+4R1WXAjY4wnvY1WDCBN5CNLLIo4RPuli2R81HZ4OpZuiHv81sNMccauhrJrioDdbxhxbM7/jQ6M9YajwdNisL5zClXCOs1/y01+9vDiMDk0kX8hiIYlpPKDwjqQQJBAL6Y0fuoJng57GGhdwvN2c656tLDPj9GRi0sfeeMqavRTMz6/qea1LdAuzDhRoS2Wb8ArhOkYns0GMazzc1q428CQQC6sM9OiVR4EV/ewGnBnF+0p3alcYr//Gp1wZ6fKIrFJQpbHTzf27AhKgOJ1qB6A7P/mQS6JvYDPsgrVkPLRnX7AkEAr/xpfyXfB4nsUqWFR3f2UiRmx98RfdlEePeo9YFzNTvX3zkuo9GZ8e8qKNMJiwbYzT0yft59NGeBLQ/eynqUrwJAE6Nxy0Mq/Y5mVVpMRa+babeMBY9SHeeBk22QsBFlt6NT2Y3Tz4CeoH547NEFBJDLKIICO0rJ6kF6cQScERASbQJAZy088sVY6DJtGRLPuysv3NiyfEvikmczCEkDPex4shvFLddwNUlmhzml5pscIie44mBOJ0uX37y+co3q6UoRQg==-----END PRIVATE KEY-----&quot;&quot;&quot;pubkey = RSA.import_key(pubkey)prikey = RSA.import_key(prikey)n = pubkey.njsonPath = FlowAnalyzer.get_json_data(&quot;/tmp/webshell_pro.pcapng&quot;, display_filter=&quot;http&quot;)def dec_replace(base64_str: str): base64_str = base64_str.replace(&quot;e5Lg^FM5EQYe5!yF&amp;62%V$UG*B*RfQeM&quot;, &quot;/&quot;) base64_str = base64_str.replace(&quot;n6&amp;B8G6nE@2tt4UR6h3QBt*5&amp;C&amp;pVu8W&quot;, &quot;+&quot;) return base64_str.replace(&quot;JXWUDuLUgwRLKD9fD6&amp;VY2aFeE&amp;r@Ff2&quot;, &quot;=&quot;).encode()def decrypt(cipher_text): # 公钥解密 cipher_text = base64.b64decode(dec_replace(cipher_text)) plain_text = b&quot;&quot; for i in range(0, len(cipher_text), 128): part = cipher_text[i:i+128] dec = libnum.n2s(pow(libnum.s2n(part), pubkey.e, n)) plain_text += dec return plain_text.decode()for request, response in FlowAnalyzer(jsonPath).generate_http_dict_pairs(): if request: file_data = parse.parse_qs(request.file_data)[b&#x27;shell&#x27;][0] print(decrypt(file_data.decode())) 运行得出以下内容： 123456789101112131415┌──(kali㉿kali)-[~/桌面]└─$ python3 decode.py whoamiipconfigifconfigls /ls /rootls /root/FLAGcd /root/FLAGcat 小明的日记.txtcd /root/FLAG &amp;&amp; base64 小明的日记.txtcd /root/FLAG &amp;&amp; base64 hint.pyecho U2FsdGVkX1+SslS2BbHfe3c4/t/KxLaM6ZFlOdbtfMHnG8lepnhMnde40tNOYjSvoErLzy0csL7c5d4TlMntBQ== &gt; /root/FLAG/flag.txtls /root/FLAGecho Good Luck! ByeBye~ 提取关键信息，Hacker将U2FsdGVkX1+SslS2BbHfe3c4/t/KxLaM6ZFlOdbtfMHnG8lepnhMnde40tNOYjSvoErLzy0csL7c5d4TlMntBQ==写进了&#x2F;root&#x2F;FLAG&#x2F;flag.txt文件中，这串编码看起来像Base64编码，但是尝试后不正确，结合前者的信息，应该是引入了密钥的非对称加密方法，尝试后发现为AES加密，而密钥为前面解出来的Password-based-encryption： 得到Flag：flag&#123;d0e1183c-07c3-49ea-b048-addbe6cc1b20&#125; [鹤城杯2021]流量分析下载打开附件，得到一个数据包： 使用Wireshark打开查看，简单使用协议类型排序，翻看一下可以发现这是Sql注入中布尔盲注的攻击流量： 在这回顾一下布尔盲注的知识： 布尔盲注爆出数据的原理其实是通过截取单个字符利用Ascii码来爆破字符，最后出现的Ascii码则是对应字符的Ascii码。 那根据这一性质，结合数据包中的内容，可以猜测Flag就是布尔盲注后的结果；故这有两种解法，一是根据数据包手动收集每一个字符对应的Ascii码，然后转换出来即是Flag，二则是通过脚本批量转换。 解法一：手动筛选后转换 1234a = [102,108,97,103,123,119,49,114,101,115,104,65,82,75,95,101,122,95,49,115,110,116,105,116,125,126,126]characters = [chr(i) for i in a]characters = &#x27;&#x27;.join(characters)print(characters) 即得Flag：flag&#123;w1reshARK_ez_1sntit&#125; 解法二：脚本批量筛选解析 1234567891011121314151617181920212223import re# 构建正则表达式，&#x27;\\d*&#x27;等同于&#x27;[0-9]*&#x27;。pattern = re.compile(r&quot;from%20t\\),(\\d*),1\\)\\)=(\\d*)&quot;)# 使用with来读取文件，with的好处是用完后可以自动关闭文件，减少开销。# &#x27;rb&#x27;表示用二进制只读模式读取。with open(&quot;/tmp/timu.pcapng&quot;, &quot;rb&quot;) as file: # 使用utf-8解码文件，&#x27;ignore&#x27;表示如果文件包含无法使用前者编码的字节时进行忽略，并将内容存储至data变量中。 data = file.read().decode(&quot;utf-8&quot;, &quot;ignore&quot;)# 通过正则匹配文件，形成元组。matches = pattern.findall(data)flag = [&#x27;&#x27;] * 31# 对于每个元组 t，使用 lambda 函数将其第一个元素（索引）转换为整数，并将其第二个元素（ASCII 码）转换为对应的字符。然后，通过 map() 函数对 matches 中的每个元组执行这个转换，得到一个由索引和对应字符组成的元组的迭代器。接着，使用 for 循环遍历这个迭代器中的每个元组。在循环中，index 变量存储索引值，value 变量存储对应的字符。for index, value in map(lambda t: (int(t[0]), chr(int(t[1]))), matches): flag[index] = value# 将flag拼接起来。print(&#x27;&#x27;.join(flag)) 即得Flag：flag&#123;w1reshARK_ez_1sntit&#125; 压缩包攻击BugKu-请攻击这个压缩包下载获取附件，是一个加密了的压缩包，除此之外没有任何提示： 解题思路： 暴力破解 伪加密 明文攻击 若是突破点为暴力破解，应有少量的提示，大概率不可能纯暴力破解，时间太长效率不高；可以利用010editor查看是否为伪加密： 如何判断真加密伪加密？ ​\tfrFlags 和 deFlags ​\t压缩源文件数据区中的全局方式位标记是判断压缩包有无伪加密的重要标志，即压缩源文件数据区的第7、第8两个字节09 00。 ​\tZIP的压缩源文件数据区全局方式位标记在010 Editor显示的文件结构中即为ushort frFlags。 ​\t压缩文件目录区的全局方式位标记是进行伪加密的关键，即压缩文件目录区的第9、第10两个字节。 ​\tZIP的压缩文件目录区全局方式位标记在010 Editor显示的文件结构中即为ushort deFlags。 ​\t无加密的ZIP： 压缩源文件数据区的全局方式位标记应当为00 00，且压缩源文件目录区的全局方式位标记应当为00 00 真加密的ZIP: 压缩源文件数据区的全局方式位标记应当为09 00，且压缩源文件目录区的全局方式位标记应当为09 00 伪加密的ZIP: 压缩源文件数据区的全局方式位标记应当为00 00，且压缩文件目录区的全局方式位标记应当为09 00。 可以确认是真加密，那接下来往明文攻击那方向思考，查询一下压缩包明文攻击的前置条件： 第一第二点，我们并不满足，但是第三种利用7z查看加密算法后，发现可以利用： 利用ZipCrypto Store的特性，只需要知道加密压缩包内容的12个字节就可以对该压缩包进行明文攻击破解，标准Png文件的文件头都是一致的，所以我们可以拟造一个只有文件头的Png文件；Png文件头：89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52 12echo 89504E470D0A1A0A0000000D49484452 | xxd -r -ps &gt; png_header# xxd -r -ps：将16进制数转换成ASCII文本 效果是这样的： 接下来使用bkcrack工具进行明文攻击，将加密的压缩包和刚刚拟造的png_header放在同一目录下： 1234567time bkcrack -C file.zip -c flag.png -p png_header -o 0 &gt; 1.log&amp;# time：加上time参数查看计算爆破时间# -C：选择加密压缩包# -c：选择压缩包的密文部分# -p：选择的明文文件# -o：指定的明文在压缩包内目标文件的偏移量# &gt; 1.log&amp;：后台运行，并将结果存入1.log 工具链接：https://github.com/kimci86/bkcrack 12# 使用以下命令查看进度 tail -f 1.log 可以获得三段密钥：92802c24 9955f8d6 65c652b8 利用这三段密钥即可把flag.png文件取出来： 1bkcrack -C file.zip -c flag.png -k 92802c24 9955f8d6 65c652b8 -d try.png 在同级目录下即可获得try.png： 打开图片即可获得Flag： 即得Flag：BugKu&#123;不是非得两个文件你才能明文攻击&#125;"}]